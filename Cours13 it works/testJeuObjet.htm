<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Test objet</title>
    <style>
        p {
            color: black;
            font-weight: bold;
            font-family: Georgia;
            font-size: 16pt;
            text-align: center;
            width: 640px;
        }

        .padding {
            padding: 10px 15px 10px 15px;
        }

        .titre {
            color: black;
            font-weight: bold;
            font-family: Georgia;
            font-size: 28pt;
            text-align: center;
            width: 640px;
        }
    </style>
    <script type="text/javascript" src="WebGl.js"></script>
    <script type="text/javascript" src="ShaderCouleursTextures.js"></script>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="Transformations.js"></script>
    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="Sol.js"></script>
    <script type="text/javascript" src="Murs.js"></script>
    <script type="text/javascript" src="Creneaux.js"></script>
    <script type="text/javascript" src="Tunnels.js"></script>
    <script type="text/javascript" src="Ciel.js"></script>
    <script type="text/javascript" src="Textures.js"></script>
    <script type="text/javascript" src="Fleche.js"></script>
    <script type="text/javascript" src="Tresor.js"></script>
    <script type="text/javascript" src="Rectangle.js"></script>
    <script type="text/javascript" src="Joueur.js"></script>
    <script type="text/javascript" src="TeleTransporteurs.js"></script>
    <script type="text/javascript" src="TeleRecepteurs.js"></script>
    <script type="text/javascript">

        //Le téléporteur ne marche pas
        //prevent score from lowering if no wall

        //Variables globales
        let objgl = null;
        let objProgShaders = null;
        let objScene3D = null;
        //Pour vérifier savoir si une case est vide ou non, au moment d'ajouté un objet sur une case vide la valeur de cette case passera de 'v' à 'V'
        const m = 'm';
        const v = 'v';
        const d = 'd';
        const c = 'c';
        const j = 'j';
        const s = 's';
        const tabCarte = [
            [m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m],
            [m, v, v, v, v, v, v, v, v, v, v, v, v, v, v, d, v, v, v, v, v, v, v, v, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, d, d, d, d, v, d, v, d, d, d, d, d, v, d, d, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, v, v, d, v, v, v, d, v, d, v, d, v, v, v, d, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, d, d, d, d, v, d, d, v, d, d, v, d, v, d, d, v, d, d, v, d, d, d, d, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, v, d, d, d, v, d, v, d, d, d, v, d, v, d, d, d, v, d, v, d, d, d, v, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, v, d, d, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, d, d, v, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, d, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, d, v, d, d, d, v, d, v, d, v, d, v, d, d, d, v, d, v, v, v, v, v, v, m],
            [m, d, d, d, d, d, v, d, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, d, v, d, d, d, d, d, m],
            [m, v, v, v, v, v, v, d, v, d, d, d, v, c, c, s, c, c, v, d, d, d, v, d, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, v, d, v, c, j, j, j, c, v, d, v, d, v, d, d, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, c, j, j, j, c, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, d, d, d, d, v, d, v, d, v, c, j, j, j, c, v, d, v, d, v, d, d, d, d, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, c, c, c, c, c, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, v, d, v, v, v, v, v, v, v, d, v, d, v, d, d, d, d, d, d, v, m],
            [m, v, d, v, v, v, v, v, v, d, v, d, d, d, d, v, d, d, d, d, v, d, v, v, v, v, v, v, d, v, m],
            [m, v, d, v, d, d, d, d, v, d, v, v, v, v, d, v, d, v, v, v, v, d, v, d, d, d, d, v, d, v, m],
            [m, v, d, v, d, v, v, v, v, d, v, d, v, v, d, v, d, v, v, d, v, d, v, v, v, v, d, v, d, v, m],
            [m, v, d, v, d, d, d, d, v, d, v, d, v, d, d, v, d, d, v, d, v, d, v, d, d, d, d, v, d, v, m],
            [m, v, v, v, v, v, v, d, v, d, v, v, v, d, v, v, v, d, v, v, v, d, v, d, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, v, d, v, d, v, d, d, d, v, d, v, d, d, d, v, d, v, d, v, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, d, v, v, v, d, v, v, v, v, v, v, v, d, v, v, v, d, v, v, v, v, v, v, m],
            [m, v, d, v, d, d, v, d, v, d, d, d, v, d, d, v, d, d, v, d, d, d, v, d, v, d, d, v, d, v, m],
            [m, v, d, v, d, v, v, d, v, d, v, v, v, d, v, v, v, d, v, v, v, d, v, d, v, v, d, v, d, v, m],
            [m, d, d, v, d, d, d, d, v, d, v, d, d, d, d, d, d, d, d, d, v, d, v, d, d, d, d, v, d, d, m],
            [m, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, m],
            [m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m]
        ];

        const nbMursExt = 120;
        const nbMur = 364 + nbMursExt;

        /*Cette section est utilisé pour pouvoir itérer sur les objets 3D avec leur nom et, s'il y
        en a plusieurs, pouvoir utiliser une boucle avec le nombre connu d'objets 3D de ce type
        comme pour les flèches*/
        const OBJ3D_SOL = 0;
        const OBJ3D_ENCLOS = 1;
        const OBJ3D_CIEL = 2;
        const OBJ3D_JOUEUR = 3;
        const OBJ3D_TRESOR = 4;
        const OBJ3D_FLECHE = 5;
        var OBJ3D_MURSINTERIEUR;

        const OBJ3D_TELETRANSP = 0;
        let OBJ3D_TELERECPT;

        var obj3DPorte;

        const tabImages = ['assets/images/Sol.jpg', 'assets/images/Mur.jpg', 'assets/images/Ciel.jpg', 'assets/images/Fleche.jpg',
            'assets/images/TresorTextureGaucheDroite.jpg', 'assets/images/TresorTextureFace.jpg', 'assets/images/TresorTexturePanneauFaceHaut.jpg', 'assets/images/TresorTextureFaceArriereBas.jpg',
            'assets/images/TresorTextureArriere.jpg', 'assets/images/TresorTextureDessus.jpg', 'assets/images/Joueur.png',
            'assets/images/TextureMurMilieuFace.jpg',
            'assets/images/TextureMurMilieuCote.jpg',
            'assets/images/TextureMurDedaleFace.jpg',
            'assets/images/TextureMurDedaleCote.jpg',
            'assets/images/teleTransporteur.jpg',
            'assets/images/teleRecepteur.jpg',
            'assets/images/enclos.jpg'
        ];
        const TEX_SOL = 0;
        const TEX_MUR = 1;
        const TEX_CIEL = 2;
        const TEX_FLECHE = 3;
        const TEX_TRESORGAUCHEDROITE = 4
        const TEX_TRESORFACE = 5;
        const TEX_TRESORFACEHAUT = 6
        const TEX_TRESORFACEARRIEREBAS = 7;
        const TEX_TRESORARRIERE = 8;
        const TEX_TRESORDESSUS = 9;
        const TEX_JOUEUR = 10;
        const TEX_MURMILIEUFACE = 11;
        const TEX_MURMILIEUCOTE = 12;
        const TEX_MURDEDALEFACE = 13;
        const TEX_MURDEDALECOTE = 14;
        const TEX_TELETRANSP = 15;
        const TEX_TELERECEPT = 16;
        const TEX_ENCLOS = 17

        let isRestrictKeysActive = false;
        let previousCameraPosition = null;
        let previousCameraDirection = null;

        let positionInitaleJoueur = [15, 0.5, 15];
        let directionInitialeJoueur = [-15, 0, 15];

        //Score
        let intScore = 300

        //Longueur et largeur du niveau
        let longueurLargeurCarte = 31;

        //Le nombre d'ouvreurs de murs : 4 (- 1 à chaque 2 niveaux)
        let nbOuvreurs;

        // Le niveau actuel du jeu
        let intNiveau = 3;

        // Le nombre de flèches : 18 - (intNiveau *2)
        let nbFleches;

        let nbGameOver = 0;
        let nbGagnees = 0;

        const minutesInitiales = 0;
        const secondsInitiales = 60;

        let minutes = minutesInitiales;
        let seconds = secondsInitiales;
        let timerInterval;

        //Les murs ouverts. Leur Y est négatif pour les cacher. Nous n'aurons qu'à remettre leur Y original à la fin du niveau
        let tabMursOuverts = [];

        let tabElementsNiveau;

        //Le nombre de télé-transporteurs : ((intNiveau+1)/2 | 0)
        let nbTeleTransps;

        //Le nombre de télé-récepteurs : intNiveau
        let nbTeleRecepts;

        //voir s'il peut se téléporter
        let binTP = true;

        function demarrer() {
            const formattedMinutes = minutes.toString().padStart(2, '0');
            const formattedSeconds = seconds.toString().padStart(2, '0');
            document.getElementById('lblTemps').textContent = `${formattedMinutes}:${formattedSeconds}`;

            const objCanvas = document.getElementById('monCanvas');
            objgl = initWebGL(objCanvas);  // Initialise le contexte WebGL
            objProgShaders = initShaders(objgl);
            objSons = initSons();
            objScene3D = initScene3D(objgl); // Créer la scène

            objSons.ambiance.play();
            document.addEventListener('keydown', startTimer);

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
            animer();
        }

        // Un cycle d'animation	
        function animer() {
            // Requête pour le prochain cycle
            objCycleAnimation = requestAnimationFrame(animer);

            // Le cycle d'animation
            effacerCanevas(objgl);
            mettreAjourAnimation();
            dessiner(objgl, objProgShaders, objScene3D);
        }

        // Pour mettre à jour l'animation
        function mettreAjourAnimation() {
            document.getElementById('lblOuvreursMurs').innerHTML = nbOuvreurs
            document.getElementById('lblScore').innerHTML = intScore;

            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + i];
                tournerFleche(i);
            }
        }

        function tournerFleche(intNoFleche) {
            const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + intNoFleche];
            let fltAngleY = getAngleY(obj3DFleche.transformations) + 0.5;
            if (fltAngleY > 360) fltAngleY -= 360;
            setAngleY(fltAngleY, obj3DFleche.transformations);
        }

        function initScene3D(objgl) {
            document.getElementById('lblNiveau').innerHTML = intNiveau + 1
            nbFleches = 18 - (intNiveau * 2);
            nbOuvreurs = 4 - (intNiveau/2 | 0);
            nbTeleTransps = ((intNiveau + 1) / 2 | 0);
            nbTeleRecepts = intNiveau;
            OBJ3D_TELERECPT = OBJ3D_TELETRANSP + nbTeleTransps;

            OBJ3D_MURSINTERIEUR = 6 + nbFleches

            const objScene3D = new Object();
            const tabObjets3D = new Array();
            const tabTeles3D = new Array();

            // Mettre les textures dans la scène
            objScene3D.textures = creerTextures(objgl, tabImages);

            // Créer le sol
            const obj3DSol = creerObj3DSol(objgl, longueurLargeurCarte, TEX_SOL);
            tabObjets3D.push(obj3DSol);

            // Créer le sol de l'enclos
            const obj3DSolEnclos = creerObj3DSol(objgl, 3, TEX_ENCLOS, intNiveau);
            obj3DSolEnclos.vertex = creerVertexSol(objgl, 3, 3, 0.1);
            setPositionX(13.5, obj3DSolEnclos.transformations);
            setPositionZ(13.5, obj3DSolEnclos.transformations);
            tabObjets3D.push(obj3DSolEnclos);

            // Créer le ciel
            const obj3DCiel = creerObj3DCiel(objgl, longueurLargeurCarte, TEX_CIEL);
            tabObjets3D.push(obj3DCiel);

            //Créer Joueur (la flèche sur la carte)
            const obj3DJoueur = creerObj3DJoueur(objgl, TEX_JOUEUR);
            tabObjets3D.push(obj3DJoueur);

            //Créer Trésor
            const obj3DTresor = creerObj3DTresor(objgl, [TEX_TRESORGAUCHEDROITE, TEX_TRESORFACE, TEX_TRESORFACEHAUT,
                TEX_TRESORFACEARRIEREBAS, TEX_TRESORARRIERE, TEX_TRESORDESSUS])
            tabObjets3D.push(obj3DTresor);
            randomisationPositionTresor(obj3DTresor, tabCarte);
            // setPositionTresor(13, 15, obj3DTresor) //devant le joueur dans l'enclos

            //Créer Flèche
            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = creerObj3DFleche(objgl, TEX_FLECHE);
                tabObjets3D.push(obj3DFleche);
                randomisationPositionFleche(obj3DFleche, tabCarte);
            }

            //Créer Mur du milieu
            // lire les données du tableau de la carte
            for (let i = 0; i < tabCarte.length; i++) {
                for (let j = 0; j < tabCarte[i].length; j++) {
                    if (tabCarte[i][j] == c) {
                        const obj3DMurMilieu = creerObj3DRectangle(objgl, [TEX_MURMILIEUFACE, TEX_MURMILIEUCOTE]);
                        tabObjets3D.push(obj3DMurMilieu);
                        setPositionRectangle(i, j, obj3DMurMilieu)
                    }
                    else if (tabCarte[i][j] == d) {
                        const obj3DMurDedale = creerObj3DRectangle(objgl, [TEX_MURDEDALEFACE, TEX_MURDEDALECOTE]);
                        tabObjets3D.push(obj3DMurDedale);
                        setPositionRectangle(i, j, obj3DMurDedale)
                    }
                    else if (tabCarte[i][j] == s) {
                        const obj3DPorte = creerObj3DRectangle(objgl, [TEX_MURMILIEUFACE, TEX_MURMILIEUCOTE]);
                        obj3DPorte.binVisible = false;
                        obj3DPorte.binBriser = true;
                        obj3DPorte.lettre = 's';
                        tabObjets3D.push(obj3DPorte);
                        setPositionRectangle(i, j, obj3DPorte);
                        console.log(tabObjets3D);
                    }
                    else if (tabCarte[i][j] == m) {
                        const obj3DMur = creerObj3DMur(objgl, [TEX_MUR, TEX_MUR]);
                        obj3DMur.binVisible = true;
                        obj3DMur.binBriser = false;
                        obj3DMur.lettre = 'm';
                        tabObjets3D.push(obj3DMur);
                        setPositionMur(i, j, obj3DMur);
                    }
                }
            }

            //Créer Télé-Transporteur
            for (let i = 0; i < nbTeleTransps; i++) {
                const obj3DTransp = creerObj3DTeleTransporteurs(objgl, TEX_TELETRANSP);
                tabTeles3D.push(obj3DTransp);
                randomisationPositionTransp(obj3DTransp, tabCarte);
            }

            //Créer Télé-Récepteur
            for (let i = 0; i < nbTeleRecepts; i++) {
                const obj3DTeleR = creerObj3DTeleRecepteurs(objgl, TEX_TELERECEPT);
                tabTeles3D.push(obj3DTeleR);
                randomisationPositionRecept(obj3DTeleR, tabCarte);
            }

            // Mettre les objets 3D sur la scène
            objScene3D.tabObjets3D = tabObjets3D;

            //Mettre les télés sur la scène
            objScene3D.tabTeles3D = tabTeles3D;

            // La caméra
            const camera = creerCamera();
            //POUR QUE LA COLLISION FONTIONNE IL FAUT QUE LA CAMERA COOMMENCE AVEC UN ORIENTATION LÉGÈREMENT DÉCALÉE PAE RAPPORT AU MUR
            setPositionsCameraXYZ(positionInitaleJoueur, camera);
            setCiblesCameraXYZ(directionInitialeJoueur, camera);
            setOrientationsXYZ([0, 1, 0], camera);
            objScene3D.camera = camera;

            //Oriente les flèches vers le trésor
            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + i];
                trouverCoffre(obj3DFleche, obj3DTresor);
            }
            return objScene3D;
        }

        function dessiner(objgl, objProgShaders, objScene3D) {
            // La vue
            objgl.viewport(0, 0, objgl.drawingBufferWidth, objgl.drawingBufferHeight);

            // Matrice de projection
            const matProjection = mat4.create();
            const fltRapportCanevas = objgl.drawingBufferWidth / objgl.drawingBufferHeight;
            if (isRestrictKeysActive) {
                mat4.ortho(-16, 16, -16, 16, -41, 41, matProjection);
            }
            else {
                mat4.perspective(55, fltRapportCanevas, 0.01, 50, matProjection);
            }


            // Relier la matrice aux shaders
            objgl.uniformMatrix4fv(objProgShaders.matProjection, false, matProjection);

            for (let i = 0; i < objScene3D.tabObjets3D.length; i++) {
                const vertex = objScene3D.tabObjets3D[i].vertex;
                const couleurs = objScene3D.tabObjets3D[i].couleurs;
                const texels = objScene3D.tabObjets3D[i].texels;
                const maillage = objScene3D.tabObjets3D[i].maillage;
                const transformations = objScene3D.tabObjets3D[i].transformations;

                // Matrice du modèle            
                const matModeleVue = mat4.create();
                mat4.identity(matModeleVue);

                // Placer la caméra sur la scène
                mat4.lookAt(getPositionsCameraXYZ(objScene3D.camera),
                    getCiblesCameraXYZ(objScene3D.camera),
                    getOrientationsXYZ(objScene3D.camera),
                    matModeleVue);

                // Appliquer les transformations sur le modèle 
                mat4.translate(matModeleVue, getPositionsXYZ(transformations));
                mat4.scale(matModeleVue, getEchellesXYZ(transformations));
                mat4.rotateX(matModeleVue, getAngleX(transformations) * Math.PI / 180);
                mat4.rotateZ(matModeleVue, getAngleZ(transformations) * Math.PI / 180);
                //a été déplacé pour faire tourner les flèches sur eux mêmes
                mat4.rotateY(matModeleVue, getAngleY(transformations) * Math.PI / 180);

                // Relier la matrice aux shaders
                objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

                if (maillage == null)
                    // Dessiner les sous-objets
                    for (let j = 0; j < vertex.length; j++) {

                        // Relier les vertex aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
                        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
                        const intNbVertex = (objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4) / 3;

                        // Relier les couleurs aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
                        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);

                        // Activer la texture
                        objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
                        objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels[j].intNoTexture]);

                        // Relier les texels aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
                        objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                        // Relier le no de texture et le taux de couleur aux shaders                 
                        objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
                        objgl.uniform1f(objProgShaders.pcCouleurTexel, texels[j].pcCouleurTexel);

                        // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                        if (objScene3D.tabObjets3D[i].binVisible == true) {
                            // Dessiner
                            objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
                        }
                    }
                else { // Dessiner le maillage

                    // Relier les vertex aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
                    objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);

                    // Relier les couleurs aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
                    objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0)

                    // Activer la texture
                    objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
                    objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

                    // Relier les texels aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
                    objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                    // Relier le no de texture et le taux de couleur aux shaders                 
                    objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
                    objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

                    // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
                    objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

                    // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                    if (objScene3D.tabObjets3D[i].binVisible == true) {
                        // Dessiner les triangles
                        objgl.drawElements(objgl.TRIANGLES, maillage.intNbTriangles * 3, objgl.UNSIGNED_SHORT, 0);
                        // Dessiner les droites à la suite des triangles
                        objgl.drawElements(objgl.LINES, maillage.intNbDroites * 2, objgl.UNSIGNED_SHORT, maillage.intNbTriangles * 2 * 3);
                    }
                }
            }

            //Textures pour tabTeles3D
            for (let i = 0; i < objScene3D.tabTeles3D.length; i++) {
                const vertex = objScene3D.tabTeles3D[i].vertex;
                const couleurs = objScene3D.tabTeles3D[i].couleurs;
                const texels = objScene3D.tabTeles3D[i].texels;
                const maillage = objScene3D.tabTeles3D[i].maillage;
                const transformations = objScene3D.tabTeles3D[i].transformations;

                // Matrice du modèle            
                const matModeleVue = mat4.create();
                mat4.identity(matModeleVue);

                // Placer la caméra sur la scène
                mat4.lookAt(getPositionsCameraXYZ(objScene3D.camera),
                    getCiblesCameraXYZ(objScene3D.camera),
                    getOrientationsXYZ(objScene3D.camera),
                    matModeleVue);

                // Appliquer les transformations sur le modèle 
                mat4.translate(matModeleVue, getPositionsXYZ(transformations));
                mat4.scale(matModeleVue, getEchellesXYZ(transformations));
                mat4.rotateX(matModeleVue, getAngleX(transformations) * Math.PI / 180);
                mat4.rotateZ(matModeleVue, getAngleZ(transformations) * Math.PI / 180);
                //a été déplacé pour faire tourner les flèches sur eux mêmes
                mat4.rotateY(matModeleVue, getAngleY(transformations) * Math.PI / 180);

                // Relier la matrice aux shaders
                objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

                if (maillage == null)
                    // Dessiner les sous-objets
                    for (let j = 0; j < vertex.length; j++) {

                        // Relier les vertex aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
                        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
                        const intNbVertex = (objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4) / 3;

                        // Relier les couleurs aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
                        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);

                        // Activer la texture
                        objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
                        objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels[j].intNoTexture]);

                        // Relier les texels aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
                        objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                        // Relier le no de texture et le taux de couleur aux shaders                 
                        objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
                        objgl.uniform1f(objProgShaders.pcCouleurTexel, texels[j].pcCouleurTexel);

                        // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                        if (objScene3D.tabTeles3D[i].binVisible == true) {
                            // Dessiner
                            objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
                        }
                    }
                else { // Dessiner le maillage

                    // Relier les vertex aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
                    objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);

                    // Relier les couleurs aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
                    objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0)

                    // Activer la texture
                    objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
                    objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

                    // Relier les texels aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
                    objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                    // Relier le no de texture et le taux de couleur aux shaders                 
                    objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
                    objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

                    // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
                    objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

                    // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                    if (objScene3D.tabTeles3D[i].binVisible == true) {
                        // Dessiner les triangles
                        objgl.drawElements(objgl.TRIANGLES, maillage.intNbTriangles * 3, objgl.UNSIGNED_SHORT, 0);
                        // Dessiner les droites à la suite des triangles
                        objgl.drawElements(objgl.LINES, maillage.intNbDroites * 2, objgl.UNSIGNED_SHORT, maillage.intNbTriangles * 2 * 3);
                    }
                }
            }
        }

        function effacerCanevas(objgl) {
            // Met la couleur d'effacement au noir et complétement opaque
            objgl.clearColor(0.0, 0.0, 0.0, 1.0);
            // Efface les couleurs et le buffer de profondeur.
            objgl.clear(objgl.COLOR_BUFFER_BIT | objgl.DEPTH_BUFFER_BIT);
        }

        function initSons() {
            const objSons = new Object();

            //Ce son joue lorsque le joueur brise un mur
            let objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/legos-falling-made-with-Voicemod.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.briseMur = objSon;

            // Ce son joue lorsque le joueur trouve le trésor
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/zelda.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.sonToucheTresor = objSon;

            // Ce son joue lorsque la porte de l'enclos se ferme
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/slidingDoor.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.porte = objSon;

            //Ce son joue lorsqu'il reste 5 secondes au jeu
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/destructionMur2.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.countdown = objSon;

            //Ce son joue lorsque la triche est activée
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/among-us-role-reveal-sound.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.activationTriche = objSon;

            //Ce son joue lorsque le joueur fait un Game Over
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/discord-notification.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.gameOver = objSon;

            //Ce son joue lorsque le joueur perd le niveau
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/minecraft-horse-death.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.perdNiveau = objSon;

            //Ce son joue lorsque le joueur termine le 10e niveau
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/Fortnite_Victory_Royale_Sound_Effect_TubeRipper.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.gagneJeu = objSon;

            //Ce son joue lorsque le niveau commence
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/Wii Sports Intro Music (HD).mp3');
            objSon.load();
            objSon.loop = false;
            objSons.debutNiveau = objSon;

            //Ce son joue lorsque le joueur se téléporte
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/teleportationGoku.mp3');
            objSon.load();
            objSon.loop = false;
            objSons.teleportation = objSon; //à implémenter

            //Ce son joue lorsque le joueur se téléporte
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'assets/audio/ambiance.mp3');
            objSon.load();
            objSon.loop = true;
            objSons.ambiance = objSon;

            return objSons;
        }


        //Cette fonction traque la validité des touches appuyées
        // À MODIFIER: ajouter la possibilité de triche pour voir les objets
        function restrictKeys(event) {
            // Key codes: CTRL = 17, SHIFT = 16, SPACE = 32
            var allowedKeys = [17, 16, 32];

            //Pour la triche
            if (event.ctrlKey && event.shiftKey && event.keyCode == 32) {

                binVisibleVueCarte = !objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible;

                //pour afficher les flèches
                for (let i = 0; i < nbFleches; i++) {
                    objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = binVisibleVueCarte;
                }
                objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = binVisibleVueCarte;

                for (let i = 0; i < nbTeleTransps; i++) {
                    objScene3D.tabTeles3D[OBJ3D_TELETRANSP + i].binVisible = binVisibleVueCarte;
                }
                for (let i = 0; i < nbTeleRecepts; i++) {
                    objScene3D.tabTeles3D[OBJ3D_TELERECPT + i].binVisible = binVisibleVueCarte;
                }
                //console.log("triche")
                objSons.activationTriche.play()
            }

            if (event.keyCode === 34) { // PageDown
                // Restaurer le contrôle des touches
                document.removeEventListener('keydown', restrictKeys);
                isRestrictKeysActive = false;
            }
        }

        //Permet de faire tourner les objets
        //Pour changer l'objet à tourner, changer OBJ3D_TRESOR ↓↓↓ pour l'objet désiré
        function tournerObjet(obj3D) {
            const transformations = objScene3D.tabObjets3D[obj3D].transformations;

            if (event.keyCode == 100 || event.keyCode == 102) {
                // 100:  Flèche-à-gauche NumPad; 102:Flèche-à-droite NumPad
                const intDirection = (event.keyCode == 102) ? -1 : 1;
                setAngleY(getAngleY(transformations) + 2 * intDirection, transformations);


            }
            else if (event.keyCode == 104 || event.keyCode == 98) {
                // 104:  Flèche-en-haut NumPad; 98:Flèche-en-bas NumPad
                const intDirection = (event.keyCode == 98) ? 1 : -1;
                setAngleX(getAngleX(transformations) + 2 * intDirection, transformations);
            }

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
        }

        function deplacerCamera() {
            const camera = objScene3D.camera;
            // tournerObjet(OBJ3D_MURSINTERIEUR);
            tournerObjet(OBJ3D_TRESOR);
            let fltX;
            let fltZ;
            let intDirection;
            let fltXPrime;
            let fltZPrime;
            let binAucuneCollision;
            let binCollisionTresor;
            let binCollisionMursInterieurs;
            let fltLimiteOuest2;
            let fltLimiteEst2;
            let fltLimiteNord2;
            let fltLimiteSud2;

            if (!isRestrictKeysActive && event.keyCode == 33 && intScore > 10) { // PageUp
                // Sauvegarder la position courante de la caméra
                previousCameraPosition = {
                    x: getPositionCameraX(camera),
                    y: getPositionCameraY(camera),
                    z: getPositionCameraZ(camera)
                };
                previousCameraDirection = {
                    x: getCibleCameraX(camera),
                    y: getCibleCameraY(camera),
                    z: getCibleCameraZ(camera),
                };

                //perte de points quad utilise pageup

                //Set la position de Joueur
                setPositionJoueur(previousCameraPosition.x, previousCameraPosition.z, objScene3D.tabObjets3D[OBJ3D_JOUEUR]);
                //Set l'orientation de Joueur
                setCibleJoueur(previousCameraDirection.x, previousCameraDirection.z, objScene3D.tabObjets3D[OBJ3D_JOUEUR]);

                // Bouger la caméra au millieu en haut
                setPositionCameraX(15.5, camera);
                setPositionCameraY(32, camera);
                setPositionCameraZ(15.2, camera);
                setCibleCameraX(15.5, camera);
                setCibleCameraY(0, camera); //La caméra regarde le bas
                setCibleCameraZ(15.5, camera);
                objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = false; //Cacher le ciel
                objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = false; //Afficher le ciel
                for (let i = 0; i < nbFleches; i++) {
                    objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = false;
                }
                objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = false;
                for (let i = 0; i < nbTeleTransps; i++) {
                    objScene3D.tabTeles3D[OBJ3D_TELETRANSP + i].binVisible = false;
                }
                for (let i = 0; i < nbTeleRecepts; i++) {
                    objScene3D.tabTeles3D[OBJ3D_TELERECPT + i].binVisible = false;
                }

                //Restreindre le mouvement
                document.addEventListener('keydown', restrictKeys);
                isRestrictKeysActive = true;
            } else if (isRestrictKeysActive && event.keyCode == 34) { // PageDown
                // Restaurer la position de la caméra
                if (previousCameraPosition && previousCameraDirection) {
                    setPositionCameraX(previousCameraPosition.x, camera);
                    setPositionCameraY(previousCameraPosition.y, camera);
                    setPositionCameraZ(previousCameraPosition.z, camera);
                    setCibleCameraX(previousCameraDirection.x, camera);
                    setCibleCameraY(previousCameraDirection.y, camera);
                    setCibleCameraZ(previousCameraDirection.z, camera);
                    objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = true; //Afficher le ciel
                    for (let i = 0; i < nbFleches; i++) {
                        objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = true;
                    }
                    objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = true;
                    for (let i = 0; i < nbTeleTransps; i++) {
                        objScene3D.tabTeles3D[OBJ3D_TELETRANSP + i].binVisible = true;
                    }
                    for (let i = 0; i < nbTeleRecepts; i++) {
                        objScene3D.tabTeles3D[OBJ3D_TELERECPT + i].binVisible = true;
                    }

                }
            }
            if (!isRestrictKeysActive && (event.keyCode == 37 || event.keyCode == 39)) {
                // 37:  Flèche-à-gauche; 39:Flèche-à-droite
                fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                intDirection = (event.keyCode == 37) ? -1 : 1;
                const fltAngle = intDirection * Math.PI / 18; // Tourner 10 degrés
                fltXPrime = fltX * Math.cos(fltAngle) - fltZ * Math.sin(fltAngle);
                fltZPrime = fltX * Math.sin(fltAngle) + fltZ * Math.cos(fltAngle);
                setCibleCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                setCibleCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
            }
            else
                if (!isRestrictKeysActive && (event.keyCode == 38 || event.keyCode == 40)) {
                    // 38:  Flèche-en-haut; 40:Flèche-en-bas
                    fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                    fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                    const fltRayon = Math.sqrt(fltX * fltX + fltZ * fltZ);
                    intDirection = (event.keyCode == 38) ? 1 : -1;

                    fltXPrime = intDirection * 0.2 * Math.cos(Math.acos(fltX / fltRayon));
                    fltZPrime = intDirection * 0.2 * Math.sin(Math.asin(fltZ / fltRayon));

                    if (getPositionCameraX(camera) <= 12.5 && getPositionCameraZ(camera) <= 15.5 && objScene3D.tabObjets3D[233].binBriser == true) {
                        for (let i = 0; i < nbMur; i++) {
                            if (objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].lettre == 's') {
                                objSons.porte.play();
                                objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].binVisible = true;
                                objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].binBriser = false;
                                break;
                            }
                        }
                    }

                    // Positions de la caméra
                    let fltXCamera = getPositionX(camera) + fltXPrime;
                    let fltZCamera = getPositionZ(camera) + fltZPrime;

                    //Collision avec les murs extérieurs
                    for (let i = 0; i < nbMur - 1; i++) {
                        if (objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].nom == 'mur') {
                            binCollisionMurExterieurs = collisionMur(objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i], intDirection, camera);
                            console.log(binCollisionMurExterieurs, 'murs extérieurs');
                            //si la caméra touche un mur, elle ne peut plus avancer dans cette direction
                            if (binCollisionMurExterieurs == true) {
                                break;
                            }
                        }
                    }

                    //Collision avec le Trésor
                    binCollisionTresor = collisionTresor(objScene3D.tabObjets3D[OBJ3D_TRESOR], intDirection, camera);

                    //Collision avec les murs intérieurs
                    for (let i = 0; i < nbMur - 1; i++) {
                        if (objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].nom == 'rectangle') {
                            if (objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].binBriser) {
                                binCollisionMursInterieurs = false;
                            } else {
                                binCollisionMursInterieurs = collisionRectangle(objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i], intDirection, camera);
                            }
                            //si la caméra touche un mur, elle ne peut plus avancer dans cette direction
                            console.log(binCollisionMursInterieurs, 'murs intérieurs');
                            if (binCollisionMursInterieurs == true) {
                                break;
                            }
                        }
                    }

                    if (binCollisionTresor) { // Passer à un autre niveau
                        if (intNiveau+1 >= 10) {
                            objSons.gagneJeu.play();
                            console.log('Gagné!');
                            nbGagnees++;
                            intNiveau = 0
                            document.getElementById('lblGagnees').innerHTML = nbGagnees;
                            alert('Bravo! Vous avez gagné!');
                            resetTimer();
                            recommencerJeu();
                        } else {
                            objSons.sonToucheTresor.play();
                            alert('Bravo! Vous avez trouvé le trésor! Le prochain niveau commence dès que vous appuierez sur une touche!');
                            intScore += 10 * seconds;
                            intNiveau++;
                            objScene3D = initScene3D(objgl);
                            objScene3D.tabObjets3D[233].binBriser = true;
                            resetTimer();
                        }
                    }
                    //S'il n'y a pas de collision le joueur peut bouger
                    else if (!binCollisionTresor && !binCollisionMursInterieurs && !binCollisionMurExterieurs) {
                        setCibleCameraX(getCibleCameraX(camera) + fltXPrime, camera);
                        setCibleCameraZ(getCibleCameraZ(camera) + fltZPrime, camera);
                        setPositionCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                        setPositionCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);

                        //Trouver les positions X et Z d'un recepteur random
                        var randomRecept = Math.floor(Math.random() * nbTeleRecepts);
                        var transfRecept = objScene3D.tabTeles3D[OBJ3D_TELERECPT + randomRecept].transformations;
                        var posX = getPositionX(transfRecept);
                        var posZ = getPositionZ(transfRecept);

                        //Check si la caméra va dans un des transporteurs et si oui, la téléporter au récepteur random
                        for (let i = 0; i < nbTeleTransps; i++) {
                            const transformations = objScene3D.tabTeles3D[OBJ3D_TELETRANSP + i].transformations;
                            if (getPositionCameraX(camera) <= getPositionX(transformations) + 0.25 &&
                                getPositionCameraX(camera) >= getPositionX(transformations) - 0.25 &&
                                getPositionCameraZ(camera) >= getPositionZ(transformations) - 0.25 &&
                                getPositionCameraZ(camera) <= getPositionZ(transformations) + 0.25 &&
                                binTP) {
                                objSons.teleportation.play();
                                binTP = false;
                                setPositionCameraX(posX, camera);
                                setPositionCameraZ(posZ, camera);
                            }

                        }

                        //Check si la caméra va dans un des récepteurs et si oui, la téléporter au récepteur random
                        for (let i = 0; i < nbTeleRecepts; i++) {
                            const transformations = objScene3D.tabTeles3D[OBJ3D_TELERECPT + i].transformations;
                            if (getPositionCameraX(camera) <= getPositionX(transformations) + 0.25 &&
                                getPositionCameraX(camera) >= getPositionX(transformations) - 0.25 &&
                                getPositionCameraZ(camera) >= getPositionZ(transformations) - 0.25 &&
                                getPositionCameraZ(camera) <= getPositionZ(transformations) + 0.25 &&
                                binTP) {
                                objSons.teleportation.play();

                                binTP = false;
                                setPositionCameraX(posX, camera);
                                setPositionCameraZ(posZ, camera);
                            }
                        }

                        //Check si la caméra sort du récepteur random pour qu'elle puisse se téléporter une autre fois
                        if (!(getPositionCameraX(camera) <= getPositionX(transfRecept) + 0.5 &&
                            getPositionCameraX(camera) >= getPositionX(transfRecept) - 0.5 &&
                            getPositionCameraZ(camera) >= getPositionZ(transfRecept) - 0.5 &&
                            getPositionCameraZ(camera) <= getPositionZ(transfRecept) + 0.5)) {
                            binTP = true;
                        }
                    }
                }
                else if (!isRestrictKeysActive && (event.keyCode == 32)) {//utilise ouvreur de murs
                    // 32 : espace
                    /* Trouve la direction dans laquelle le joueur regarde afin de briser le mur qui est toujours en face du joueur
                    Trouve la position du mur dans le tableau d'objet de murs et si c'est celui devant le joueur, on baisse le y de celui-ci */
                    if (nbOuvreurs > 0) {
                        objSons.briseMur.play();
                        const directionRegard = determinerDirectionRegard(camera);
                        //console.log('Direction de la caméra : ' + directionRegard);
                        if (intScore >= 50) {

                            if (nbOuvreurs > 0) {
                                const directionRegard = determinerDirectionRegard(camera);
                                console.log('Direction de la caméra : ' + directionRegard);

                                let intXDevantCamera;
                                let intZDevantCamera;

                                // Calcul des coordonnées du mur devant la caméra
                                switch (directionRegard) {
                                    case 'nord':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera)) - 1;
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera));
                                        break;
                                    case 'sud':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera)) + 1;
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera));
                                        break;
                                    case 'est':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera));
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera)) - 1;
                                        break;
                                    case 'ouest':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera));
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera)) + 1;
                                        break;
                                    case 'nord ouest':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera)) - 1;
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera)) + 1;
                                        break;
                                    case 'sud ouest':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera)) + 1;
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera)) + 1;
                                        break;
                                    case 'nord est':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera)) - 1;
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera)) - 1;
                                        break;
                                    case 'sud est':
                                        intXDevantCamera = Math.round(getPositionCameraX(camera)) + 1;
                                        intZDevantCamera = Math.round(getPositionCameraZ(camera)) - 1;
                                        break;
                                    default:
                                        console.error('Direction de la caméra invalide');
                                        return;
                                }

                                console.log(tabCarte[intXDevantCamera][intZDevantCamera]);
                                let objMurABriser;

                                if (tabCarte[intXDevantCamera][intZDevantCamera] == 'd') {
                                    for (let i = 0; i < nbMur; i++) {
                                        let tabXYZ = getPositionsXYZ(objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].transformations);
                                        if (tabXYZ[0] == intXDevantCamera && tabXYZ[2] == intZDevantCamera) {
                                            objMurABriser = objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i];
                                            break;
                                        }
                                    }
                                    tabMursOuverts.push(objMurABriser);
                                    ouvrirMur(objMurABriser);
                                    intScore -= 50;
                                    nbOuvreurs--;
                                    console.log(getPositionX(objMurABriser.transformations), getPositionZ(objMurABriser.transformations));
                                }
                            }
                        }
                    }
                }
        }

        // cette fonction permet de déterminer dans quelle direction le joueur regarde
        // appelé lorsqu'on appuie sur espace
        function determinerDirectionRegard(camera) {
            const cibleCamera = {
                x: getCibleCameraX(camera),
                z: getCibleCameraZ(camera)
            };

            // Calcule l'angle entre la position de la caméra et la cible
            const angle = Math.atan2(cibleCamera.z, cibleCamera.x) * (180 / Math.PI);

            // Convertit l'angle en une valeur entre 0 et 360 degrés
            let angle360 = (angle + 360) % 360;

            // Ajoute 360 degrés pour garantir une valeur positive
            if (angle360 < 0) {
                angle360 += 360;
            }

            // Détermine la direction en fonction de l'angle
            let direction = '';
            if ((angle360 >= 110 && angle360 < 200)) {
                direction = 'nord';
            } else if (angle360 >= 175 && angle360 < 265) {
                direction = 'nord est';
            } else if (angle360 >= 265 && angle360 < 325) {
                direction = 'est';
            } else if (angle360 >= 325 && angle360 < 360 || angle360 <= 3) {
                direction = 'sud est';
            } else if (angle360 >= 3 && angle360 < 32) {
                direction = 'sud';
            } else if (angle360 >= 35 && angle360 < 55) {
                direction = 'sud ouest';
            } else if (angle360 >= 55 && angle360 < 90) {
                direction = 'ouest';
            } else if (angle360 >= 83 && angle360 < 110) {
                direction = 'nord ouest';
            }
            // console.log(angle360)
            return direction;
        }

        function resetTimer() {
            clearInterval(timerInterval);
            document.addEventListener('keydown', startTimer);
            minutes = minutesInitiales;
            seconds = secondsInitiales;
            const formattedMinutes = minutes.toString().padStart(2, '0');
            const formattedSeconds = seconds.toString().padStart(2, '0');
            document.getElementById('lblTemps').textContent = `${formattedMinutes}:${formattedSeconds}`;
        }

        function recommencerJeu() {
            intScore = 300;
            intNiveau = 0;
            objScene3D = initScene3D(objgl);
        }

        function startTimer() {
            objSons.debutNiveau.play();
            document.removeEventListener('keydown', startTimer);
            let camera = objScene3D.camera

            timerInterval = setInterval(() => {
                seconds--;
                if (seconds < 0) {
                    seconds = 59;
                    minutes--;
                }
                // console.log(minutes, seconds)

                if (isRestrictKeysActive) {
                    intScore -= 10;
                }
                if (intScore < 10) {
                    // Restaurer la position de la caméra
                    isRestrictKeysActive = false;
                    if (previousCameraPosition && previousCameraDirection) {
                        setPositionCameraX(previousCameraPosition.x, camera);
                        setPositionCameraY(previousCameraPosition.y, camera);
                        setPositionCameraZ(previousCameraPosition.z, camera);
                        setCibleCameraX(previousCameraDirection.x, camera);
                        setCibleCameraY(previousCameraDirection.y, camera);
                        setCibleCameraZ(previousCameraDirection.z, camera);
                        objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = true; //Afficher le ciel
                        for (let i = 0; i < nbFleches; i++) {
                            objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = true;
                        }
                        objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = true;
                        for (let i = 0; i < nbTeleTransps; i++) {
                            objScene3D.tabTeles3D[OBJ3D_TELETRANSP + i].binVisible = true;
                        }
                        for (let i = 0; i < nbTeleRecepts; i++) {
                            objScene3D.tabTeles3D[OBJ3D_TELERECPT + i].binVisible = true;
                        }
                    }
                }
                if (minutes == 0 && seconds <= 5) {
                    objSons.countdown.play();
                }
                if (minutes < 0) {
                    //clearInterval(timerInterval);
                    //si le score est inférieur à 200 points, le joueur perd et c'est GAME OVER
                    if (intScore < 200) {
                        objSons.gameOver.play();
                        nbGameOver++;
                        resetTimer();
                        alert('Vous avez perdu! Le temps s\'est écoulé et vous aviez moins de 200 points! Vous pouvez recommencer le jeu en appuyant sur une touche.')
                        console.log('Temps écoulé, avec score < 200')
                        document.getElementById('lblGameOver').innerHTML = nbGameOver;
                        recommencerJeu(); //appel init3D
                        return;
                    }
                    else {
                        //Temps écoulé
                        resetTimer();
                        objSons.perdNiveau.play();
                        alert('Le temps s\'est écoulé! Vous pouvez recommencer le jeu en appuyant sur une touche.')
                        console.log('Temps écoulé, avec score > 200')
                        //recommencer le niveau
                        intScore -= 200;
                        // Le joueur est retourné au milieu du dédale
                        setPositionsCameraXYZ(positionInitaleJoueur, camera);
                        // La caméra regarde vers le sud
                        setCiblesCameraXYZ(directionInitialeJoueur, camera);

                        // Le mur de l'enclos est réouvert
                        for(let i = 0; i < nbMur; i++) {
                            if (objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].lettre == 's') {
                                objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].binVisible = false;
                                objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].binBriser = true;
                                break;
                            }
                        }
                       /*  objScene3D.tabObjets3D[233].binVisible = false;
                        objScene3D.tabObjets3D[233].binBriser = true;
                        console.log(objScene3D.tabObjets3D[233]); */

                        //Les murs ouverts sont fermés
                        for (let i = 0; i < tabMursOuverts.length; i++) {
                            fermerMur(tabMursOuverts[i]);
                        }
                        //Le tableau de murs ouverts est vidé
                        tabMursOuverts.length = 0;
                        //Le nombre d'ouvreurs de murs est réinitialisé
                        nbOuvreurs = 4 - (intNiveau/2 | 0);

                        // Restaurer la position de la caméra
                        isRestrictKeysActive = false;
                        if (positionInitaleJoueur && directionInitialeJoueur) {
                            setPositionCameraXYZ(previousCameraPosition, camera);
                            setCibleCameraXYZ(directionInitialeJoueur, camera);

                            objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = true; //Afficher le ciel
                            for (let i = 0; i < nbFleches; i++) {
                                objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = true;
                            }
                            objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = true;
                            for (let i = 0; i < nbTeleTransps; i++) {
                                objScene3D.tabTeles3D[OBJ3D_TELETRANSP + i].binVisible = true;
                            }
                            for (let i = 0; i < nbTeleRecepts; i++) {
                                objScene3D.tabTeles3D[OBJ3D_TELERECPT + i].binVisible = true;
                            }
                        }

                        //attendre que le joueur appuie sur une touche pour recommencer
                        document.addEventListener('keydown', startTimer);
                    }
                }
                else {
                    const formattedMinutes = minutes.toString().padStart(2, '0');
                    const formattedSeconds = seconds.toString().padStart(2, '0');
                    document.getElementById('lblTemps').textContent = `${formattedMinutes}:${formattedSeconds}`;
                }
            }, 1000);
        }
    </script>
</head>

<body onload="demarrer()">
    <p class="titre"> Thesaurus Niveau: <span id="lblNiveau">1</span></p>
    <canvas id="monCanvas" width="640" height="640" tabIndex="1" onkeydown="deplacerCamera(); return false">
        Votre navigateur ne supporte pas la balise canvas
    </canvas>
    <p>
        <span class="padding">Score : <span id="lblScore">300</span></span>
        <span class="padding">Ouvreurs de murs : <span id="lblOuvreursMurs">4</span></span>
        <span class="padding">Temps : <span id="lblTemps">
                <script></script>
            </span></span>
    <p class="padding">Nombre de Game Over : <span id="lblGameOver">0</span></p>
    <p class="padding">Nombre de parties gagnées : <span id="lblGagnees">0</span></p>
    </p>

</body>

</html>