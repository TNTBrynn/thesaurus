<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Test objet</title>
    <style>
        p {
            color: black;
            font-weight: bold;
            font-family: Georgia;
            font-size: 16pt;
            text-align: center;
            width: 640px;
        }

        .padding {
            padding: 10px 15px 10px 15px;
        }

        .titre {
            color: black;
            font-weight: bold;
            font-family: Georgia;
            font-size: 28pt;
            text-align: center;
            width: 640px;
        }
    </style>
    <script type="text/javascript" src="WebGl.js"></script>
    <script type="text/javascript" src="ShaderCouleursTextures.js"></script>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="Transformations.js"></script>
    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="Sol.js"></script>
    <script type="text/javascript" src="Murs.js"></script>
    <script type="text/javascript" src="Creneaux.js"></script>
    <script type="text/javascript" src="Tunnels.js"></script>
    <script type="text/javascript" src="Ciel.js"></script>
    <script type="text/javascript" src="Textures.js"></script>
    <script type="text/javascript" src="Fleche.js"></script>
    <script type="text/javascript" src="Tresor.js"></script>
    <script type="text/javascript" src="Rectangle.js"></script>
    <script type="text/javascript" src="Joueur.js"></script>
    <script type="text/javascript">

        let objgl = null;
        let objProgShaders = null;
        let objScene3D = null;
        //Pour vérifier savoir si une case est vide ou non, au moment d'ajouté un objet sur une case vide la valeur de cette case passera de 'v' à 'V'
        const m = 'm';
        const v = 'v';
        const d = 'd';
        const c = 'c';
        const j = 'j';
        const s = 's';
        const tabCarte = [
            [m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m],
            [m, v, v, v, v, v, v, v, v, v, v, v, v, v, v, d, v, v, v, v, v, v, v, v, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, d, d, d, d, v, d, v, d, d, d, d, d, v, d, d, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, v, v, d, v, v, v, d, v, d, v, d, v, v, v, d, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, d, d, d, d, v, d, d, v, d, d, v, d, v, d, d, v, d, d, v, d, d, d, d, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, v, d, d, d, v, d, v, d, d, d, v, d, v, d, d, d, v, d, v, d, d, d, v, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, v, d, d, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, d, d, v, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, v, d, d, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, d, v, d, d, d, v, d, v, d, v, d, v, d, d, d, v, d, v, v, v, v, v, v, m],
            [m, d, d, d, d, d, v, d, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, d, v, d, d, d, d, d, m],
            [m, v, v, v, v, v, v, d, v, d, d, d, v, c, c, s, c, c, v, d, d, d, v, d, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, v, d, v, c, j, j, j, c, v, d, v, d, v, d, d, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, c, j, j, j, c, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, d, d, d, d, d, d, d, v, d, v, d, v, c, j, j, j, c, v, d, v, d, v, d, d, d, d, d, d, d, m],
            [m, v, v, v, v, v, v, v, v, d, v, d, v, c, c, c, c, c, v, d, v, d, v, v, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, d, d, v, d, v, d, v, v, v, v, v, v, v, d, v, d, v, d, d, d, d, d, d, v, m],
            [m, v, d, v, v, v, v, v, v, d, v, d, d, d, d, v, d, d, d, d, v, d, v, v, v, v, v, v, d, v, m],
            [m, v, d, v, d, d, d, d, v, d, v, v, v, v, d, v, d, v, v, v, v, d, v, d, d, d, d, v, d, v, m],
            [m, v, d, v, d, v, v, v, v, d, v, d, v, v, d, v, d, v, v, d, v, d, v, v, v, v, d, v, d, v, m],
            [m, v, d, v, d, d, d, d, v, d, v, d, v, d, d, v, d, d, v, d, v, d, v, d, d, d, d, v, d, v, m],
            [m, v, v, v, v, v, v, d, v, d, v, v, v, d, v, v, v, d, v, v, v, d, v, d, v, v, v, v, v, v, m],
            [m, v, d, d, d, d, v, d, v, d, v, d, d, d, v, d, v, d, d, d, v, d, v, d, v, d, d, d, d, v, m],
            [m, v, v, v, v, v, v, d, v, v, v, d, v, v, v, v, v, v, v, d, v, v, v, d, v, v, v, v, v, v, m],
            [m, v, d, v, d, d, v, d, v, d, d, d, v, d, d, v, d, d, v, d, d, d, v, d, v, d, d, v, d, v, m],
            [m, v, d, v, d, v, v, d, v, d, v, v, v, d, v, v, v, d, v, v, v, d, v, d, v, v, d, v, d, v, m],
            [m, d, d, v, d, d, d, d, v, d, v, d, d, d, d, d, d, d, d, d, v, d, v, d, d, d, d, v, d, d, m],
            [m, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, v, m],
            [m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m]
        ];

        const nbMur = 265;

        /*Cette section est utilisé pour pouvoir itérer sur les objets 3D avec leur nom et, s'il y
        en a plusieurs, pouvoir utiliser une boucle avec le nombre connu d'objets 3D de ce type
        comme pour les flèches*/
        const OBJ3D_SOL = 0;
        const OBJ3D_MURSEXTERIEUR = 1;
        const OBJ3D_CIEL = 2;
        const OBJ3D_JOUEUR = 3;
        const OBJ3D_TRESOR = 4;
        const OBJ3D_FLECHE = 5;
        const OBJ3D_MURSINTERIEUR = 6;
        const OBJ3D_MURSDEDALE = 7;

        const tabImages = ['assets/Sol64.jpg', 'assets/Mur.jpg', 'assets/Ciel.jpg', 'assets/Fleche.jpg',
            'assets/TresorTextureGaucheDroite.jpg', 'assets/TresorTextureFace.jpg', 'assets/TresorTexturePanneauFaceHaut.jpg', 'assets/TresorTextureFaceArriereBas.jpg',
            'assets/TresorTextureArriere.jpg', 'assets/TresorTextureDessus.jpg', 'assets/Joueur.png',
            'assets/TextureMurMilieuFace64.jpg',
            'assets/TextureMurMilieuCote64.jpg',
            'assets/TextureMurDedaleFace64.jpg',
            'assets/TextureMurDedaleCote64.jpg'
        ];
        const TEX_SOL = 0;
        const TEX_MUR = 1;
        const TEX_CIEL = 2;
        const TEX_FLECHE = 3;
        const TEX_TRESORGAUCHEDROITE = 4;
        const TEX_TRESORFACE = 5;
        const TEX_TRESORFACEHAUT = 6
        const TEX_TRESORFACEARRIEREBAS = 7;
        const TEX_TRESORARRIERE = 8;
        const TEX_TRESORDESSUS = 9;
        const TEX_JOUEUR = 10;
        const TEX_MURMILIEUFACE = 11;
        const TEX_MURMILIEUCOTE = 12;
        const TEX_MURDEDALEFACE = 13;
        const TEX_MURDEDALECOTE = 14;

        let isRestrictKeysActive = false;
        let previousCameraPosition = null;
        let previousCameraDirection = null;

        //Score
        let intScore = 300

        //Longueur et largeur du niveau
        let longueurLargeurCarte = 30;

        //Le nombre d'ouvreurs de murs : 4 (- 1 à chaque 2 niveaux)
        let nbOuvreurs = 4;

        // Le niveau actuel du jeu
        let intNiveau = 0;

        // Le nombre de flèches : 18 - (intNiveau *2)
        let nbFleches;

        let minutes = 1;
        let seconds = 0;

        //Les murs ouverts. Leur Y est négatif pour les cacher. Nous n'aurons qu'à remettre leur Y original à la fin du niveau
        let tabMursOuverts = [];

        let tabElementsNiveau;
        const csvURL = 'niveau1.csv';

        function demarrer() {
            const objCanvas = document.getElementById('monCanvas');
            objgl = initWebGL(objCanvas);  // Initialise le contexte WebGL
            objProgShaders = initShaders(objgl);
            // objSons = initSons();
            objScene3D = initScene3D(objgl); // Créer la scène

            document.addEventListener('keydown', startTimer);

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
            animer();
        }

        // Un cycle d'animation	
        function animer() {
            // Requête pour le prochain cycle
            objCycleAnimation = requestAnimationFrame(animer);

            // Le cycle d'animation
            effacerCanevas(objgl);
            mettreAjourAnimation();
            dessiner(objgl, objProgShaders, objScene3D);
        }

        // Pour mettre à jour l'animation
        function mettreAjourAnimation() {
            document.getElementById('lblOuvreursMurs').innerHTML = nbOuvreurs;
            document.getElementById('lblScore').innerHTML = intScore;

            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + i];
                tournerFleche(i);
            }
        }

        function tournerFleche(intNoFleche) {
            const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + intNoFleche];
            let fltAngleY = getAngleY(obj3DFleche.transformations) + 0.5;
            if (fltAngleY > 360) fltAngleY -= 360;
            setAngleY(fltAngleY, obj3DFleche.transformations);
        }

        function initScene3D(objgl) {
            document.getElementById('lblNiveau').innerHTML = intNiveau + 1
            nbFleches = 18 - (intNiveau * 2);
            (intNiveau % 2 === 0) ? nbOuvreurs = 4 - (intNiveau / 2) : nbOuvreurs = 4 - ((intNiveau - 1) / 2);

            const objScene3D = new Object();
            const tabObjets3D = new Array();

            // Mettre les textures dans la scène
            objScene3D.textures = creerTextures(objgl, tabImages);

            // Créer le sol
            const obj3DSol = creerObj3DSol(objgl, longueurLargeurCarte, TEX_SOL, intNiveau);
            tabObjets3D.push(obj3DSol);

            // Créer les murs
            const obj3DMurs = creerObj3DMurs(objgl, longueurLargeurCarte, TEX_MUR, intNiveau);
            tabObjets3D.push(obj3DMurs);

            // Créer le ciel
            const obj3DCiel = creerObj3DCiel(objgl, longueurLargeurCarte, TEX_CIEL);
            tabObjets3D.push(obj3DCiel);

            //Créer Joueur (la flèche sur la carte)
            const obj3DJoueur = creerObj3DJoueur(objgl, TEX_JOUEUR);
            tabObjets3D.push(obj3DJoueur);

            //Créer Trésor
            const obj3DTresor = creerObj3DTresor(objgl, [TEX_TRESORGAUCHEDROITE, TEX_TRESORFACE, TEX_TRESORFACEHAUT,
                TEX_TRESORFACEARRIEREBAS, TEX_TRESORARRIERE, TEX_TRESORDESSUS])
            tabObjets3D.push(obj3DTresor);
            randomisationPositionTresor(obj3DTresor, tabCarte);

            //Créer Flèche
            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = creerObj3DFleche(objgl, TEX_FLECHE);
                tabObjets3D.push(obj3DFleche);
                randomisationPositionFleche(obj3DFleche, tabCarte);
            }

            //Créer Mur du milieu
            // lire les données du tableau de la carte
            for (let i = 0; i < tabCarte.length; i++) {
                for (let j = 0; j < tabCarte[i].length; j++) {
                    if (tabCarte[i][j] == c) {
                        const obj3DMurMilieu = creerObj3DRectangle(objgl, false, [TEX_MURMILIEUFACE, TEX_MURMILIEUCOTE]);
                        tabObjets3D.push(obj3DMurMilieu);
                        setPositionRectangle(i, j, obj3DMurMilieu)
                    }
                    else if (tabCarte[i][j] == d) {
                        const obj3DMurDale = creerObj3DRectangle(objgl, true, [TEX_MURDEDALEFACE, TEX_MURDEDALECOTE]);
                        tabObjets3D.push(obj3DMurDale);
                        setPositionRectangle(i, j, obj3DMurDale)
                    }
                }
            }

            // Mettre les objets 3D sur la scène
            objScene3D.tabObjets3D = tabObjets3D;

            // La caméra
            const camera = creerCamera();
            //POUR QUE LA COLLISION FONTIONNE IL FAUT QUE LA CAMERA COOMMENCE AVEC UN ORIENTATION LÉGÈREMENT DÉCALÉE PAE RAPPORT AU MUR
            setPositionsCameraXYZ([15, 0.5, 15], camera);
            setCiblesCameraXYZ([-16, 0.5, 16], camera);
            setOrientationsXYZ([0, 1, 0], camera);
            objScene3D.camera = camera;

            //Oriente les flèches vers le trésor
            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + i];
                trouverCoffre(obj3DFleche, obj3DTresor);
            }
            return objScene3D;
        }

        function dessiner(objgl, objProgShaders, objScene3D) {
            // La vue
            objgl.viewport(0, 0, objgl.drawingBufferWidth, objgl.drawingBufferHeight);

            // Matrice de projection
            const matProjection = mat4.create();
            const fltRapportCanevas = objgl.drawingBufferWidth / objgl.drawingBufferHeight;
            if (isRestrictKeysActive) {
                mat4.ortho(-16, 16, -16, 16, -41, 41, matProjection);
            }
            else {
                mat4.perspective(55, fltRapportCanevas, 0.01, 50, matProjection);
            }
            // mat4.perspective(55, fltRapportCanevas, 0.01, 50, matProjection);


            // Relier la matrice aux shaders
            objgl.uniformMatrix4fv(objProgShaders.matProjection, false, matProjection);

            for (let i = 0; i < objScene3D.tabObjets3D.length; i++) {
                const vertex = objScene3D.tabObjets3D[i].vertex;
                const couleurs = objScene3D.tabObjets3D[i].couleurs;
                const texels = objScene3D.tabObjets3D[i].texels;
                const maillage = objScene3D.tabObjets3D[i].maillage;
                const transformations = objScene3D.tabObjets3D[i].transformations;

                // Matrice du modèle            
                const matModeleVue = mat4.create();
                mat4.identity(matModeleVue);

                // Placer la caméra sur la scène
                mat4.lookAt(getPositionsCameraXYZ(objScene3D.camera),
                    getCiblesCameraXYZ(objScene3D.camera),
                    getOrientationsXYZ(objScene3D.camera),
                    matModeleVue);

                // Appliquer les transformations sur le modèle 
                mat4.translate(matModeleVue, getPositionsXYZ(transformations));
                mat4.scale(matModeleVue, getEchellesXYZ(transformations));
                mat4.rotateX(matModeleVue, getAngleX(transformations) * Math.PI / 180);
                mat4.rotateZ(matModeleVue, getAngleZ(transformations) * Math.PI / 180);
                //a été déplacé pour faire tourner les flèches sur eux mêmes
                mat4.rotateY(matModeleVue, getAngleY(transformations) * Math.PI / 180);

                // Relier la matrice aux shaders
                objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

                if (maillage == null)
                    // Dessiner les sous-objets
                    for (let j = 0; j < vertex.length; j++) {

                        // Relier les vertex aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
                        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
                        const intNbVertex = (objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4) / 3;

                        // Relier les couleurs aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
                        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);

                        // Activer la texture
                        objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
                        objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels[j].intNoTexture]);

                        // Relier les texels aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
                        objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                        // Relier le no de texture et le taux de couleur aux shaders                 
                        objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
                        objgl.uniform1f(objProgShaders.pcCouleurTexel, texels[j].pcCouleurTexel);

                        // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                        if (objScene3D.tabObjets3D[i].binVisible == true) {
                            // Dessiner
                            objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
                        }
                    }
                else { // Dessiner le maillage

                    // Relier les vertex aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
                    objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);

                    // Relier les couleurs aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
                    objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0)

                    // Activer la texture
                    objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
                    objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

                    // Relier les texels aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
                    objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                    // Relier le no de texture et le taux de couleur aux shaders                 
                    objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
                    objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

                    // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
                    objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

                    // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                    if (objScene3D.tabObjets3D[i].binVisible == true) {
                        // Dessiner les triangles
                        objgl.drawElements(objgl.TRIANGLES, maillage.intNbTriangles * 3, objgl.UNSIGNED_SHORT, 0);
                        // Dessiner les droites à la suite des triangles
                        objgl.drawElements(objgl.LINES, maillage.intNbDroites * 2, objgl.UNSIGNED_SHORT, maillage.intNbTriangles * 2 * 3);
                    }
                }
            }
        }

        function effacerCanevas(objgl) {
            // Met la couleur d'effacement au noir et complétement opaque
            objgl.clearColor(0.0, 0.0, 0.0, 1.0);
            // Efface les couleurs et le buffer de profondeur.
            objgl.clear(objgl.COLOR_BUFFER_BIT | objgl.DEPTH_BUFFER_BIT);
        }

        /*  function initSons() {
             const objSons = new Object();
 
             // Ce son joue tout au long du jeu
             let objSon = document.createElement('audio');
             objSon.setAttribute('src', 'SonVent.mp3');
             objSon.load();
             objSon.loop = true;
             objSons.sonVent = objSon;
 
             // Ce son joue lorsque le joueur passe au prochain niveau
             objSon = document.createElement('audio');
             objSon.setAttribute('src', 'SonNextLevel.mp3');
             objSon.load();
             objSon.loop = true;
             objSons.sonNextLevel = objSon;
 
             // Ce son joue lorsque le joueur est dans la tornade
             objSon = document.createElement('audio');
             objSon.setAttribute('src', 'SonTornade.mp3');
             objSon.load();
             objSon.loop = true;
             objSons.sonTornade = objSon;
 
             return objSons;
         }
  */

        //Cette fonction traque la validité des touches appuyées
        // À MODIFIER: ajouter la possibilité de triche pour voir les objets
        function restrictKeys(event) {
            // Key codes: CTRL = 17, SHIFT = 16, SPACE = 32
            var allowedKeys = [17, 16, 32];

            //Pour la triche
            if (event.ctrlKey && event.shiftKey && event.keyCode == 32) {

                binVisibleVueCarte = !objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible;

                //pour afficher les flèches
                for (let i = 0; i < nbFleches; i++) {
                    objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = binVisibleVueCarte;
                }
                objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = binVisibleVueCarte;
                console.log("triche")
            }

            if (event.keyCode === 34) { // PageDown
                // Restaurer le contrôle des touches
                document.removeEventListener('keydown', restrictKeys);
                isRestrictKeysActive = false;
            }
        }

        //Permet de faire tourner les objets
        //Pour changer l'objet à tourner, changer OBJ3D_TRESOR ↓↓↓ pour l'objet désiré
        function tournerObjet(obj3D) {
            const transformations = objScene3D.tabObjets3D[obj3D].transformations;

            if (event.keyCode == 100 || event.keyCode == 102) {
                // 100:  Flèche-à-gauche NumPad; 102:Flèche-à-droite NumPad
                const intDirection = (event.keyCode == 102) ? -1 : 1;
                setAngleY(getAngleY(transformations) + 2 * intDirection, transformations);


            }
            else if (event.keyCode == 104 || event.keyCode == 98) {
                // 104:  Flèche-en-haut NumPad; 98:Flèche-en-bas NumPad
                const intDirection = (event.keyCode == 98) ? 1 : -1;
                setAngleX(getAngleX(transformations) + 2 * intDirection, transformations);
            }

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
        }

        function deplacerCamera() {
            const camera = objScene3D.camera;
            // tournerObjet(OBJ3D_MURSINTERIEUR);
            tournerObjet(OBJ3D_TRESOR);
            let fltX;
            let fltZ;
            let intDirection;
            let fltXPrime;
            let fltZPrime;
            let binAucuneCollision;
            let fltLimiteOuest2;
            let fltLimiteEst2;
            let fltLimiteNord2;
            let fltLimiteSud2;

            if (!isRestrictKeysActive && event.keyCode == 33) { // PageUp
                // Sauvegarder la position courante de la caméra
                previousCameraPosition = {
                    x: getPositionCameraX(camera),
                    y: getPositionCameraY(camera),
                    z: getPositionCameraZ(camera)
                };
                previousCameraDirection = {
                    x: getCibleCameraX(camera),
                    y: getCibleCameraY(camera),
                    z: getCibleCameraZ(camera),
                };

                //perte de points quad utilise pageup

                //Set la position de Joueur
                setPositionJoueur(previousCameraPosition.x, previousCameraPosition.z, objScene3D.tabObjets3D[OBJ3D_JOUEUR]);
                //Set l'orientation de Joueur
                setCibleJoueur(previousCameraDirection.x, previousCameraDirection.z, objScene3D.tabObjets3D[OBJ3D_JOUEUR]);

                // Bouger la caméra au millieu en haut
                setPositionCameraX(15.5, camera);
                setPositionCameraY(32, camera);
                setPositionCameraZ(15.1, camera);
                setCibleCameraX(15.5, camera);
                setCibleCameraY(0, camera); //La caméra regarde le bas
                setCibleCameraZ(15.5, camera);
                objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = false; //Cacher le ciel
                objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = false; //Afficher le ciel
                for (let i = 0; i < nbFleches; i++) {
                    objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = false;
                }
                objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = false;


                //Restreindre le mouvement
                document.addEventListener('keydown', restrictKeys);
                isRestrictKeysActive = true;
            } else if (isRestrictKeysActive && event.keyCode == 34) { // PageDown
                // Restaurer la position de la caméra
                if (previousCameraPosition && previousCameraDirection) {
                    setPositionCameraX(previousCameraPosition.x, camera);
                    setPositionCameraY(previousCameraPosition.y, camera);
                    setPositionCameraZ(previousCameraPosition.z, camera);
                    setCibleCameraX(previousCameraDirection.x, camera);
                    setCibleCameraY(previousCameraDirection.y, camera);
                    setCibleCameraZ(previousCameraDirection.z, camera);
                    objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = true; //Afficher le ciel
                    for (let i = 0; i < nbFleches; i++) {
                        objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = true;
                    }
                    objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = true;
                }
            }
            if (!isRestrictKeysActive && (event.keyCode == 37 || event.keyCode == 39)) {
                // 37:  Flèche-à-gauche; 39:Flèche-à-droite
                fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                intDirection = (event.keyCode == 37) ? -1 : 1;
                const fltAngle = intDirection * Math.PI / 18; // Tourner 10 degrés
                fltXPrime = fltX * Math.cos(fltAngle) - fltZ * Math.sin(fltAngle);
                fltZPrime = fltX * Math.sin(fltAngle) + fltZ * Math.cos(fltAngle);
                setCibleCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                setCibleCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
            }
            else
                if (!isRestrictKeysActive && (event.keyCode == 38 || event.keyCode == 40)) {
                    // 38:  Flèche-en-haut; 40:Flèche-en-bas
                    fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                    fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                    const fltRayon = Math.sqrt(fltX * fltX + fltZ * fltZ);
                    intDirection = (event.keyCode == 38) ? 1 : -1;

                    fltXPrime = intDirection * 0.2 * Math.cos(Math.acos(fltX / fltRayon));
                    fltZPrime = intDirection * 0.2 * Math.sin(Math.asin(fltZ / fltRayon));

                    // Positions de la caméra
                    let fltXCamera = getPositionX(camera) + fltXPrime;
                    let fltZCamera = getPositionZ(camera) + fltZPrime;

                    // Limites du mur
                    const fltLimiteOuest = 0.1;
                    const fltLimiteEst = objScene3D.tabObjets3D[OBJ3D_MURSEXTERIEUR].fltLargeur - 0.1;
                    const fltLimiteNord = 0.1;
                    const fltLimiteSud = objScene3D.tabObjets3D[OBJ3D_MURSEXTERIEUR].fltProfondeur - 0.1;

                    binAucuneCollision = (fltXCamera > fltLimiteOuest) && (fltXCamera < fltLimiteEst) &&
                        (fltZCamera > fltLimiteNord) && (fltZCamera < fltLimiteSud);


                    if (collisionTresor(objScene3D.tabObjets3D[OBJ3D_TRESOR], intDirection, camera)) { // Passer à un autre niveau
                        // Arrêter le son du vent
                        // objSons.sonVent.pause();
                        // objSons.sonVent.currentTime = 0.0;

                        // Jouer le son du prochain niveau
                        // objSons.sonNextLevel.play();
                        if (intNiveau == 10) {

                        } else {

                        }
                        intScore += 10*intSecondes;
                        intNiveau++;
                        objScene3D = initScene3D(objgl);
                    }
                    else if (binAucuneCollision) { // Déplacer la caméra
                        //si la caméra touche le trésor il ne peut plus avancer dans cette direction et on passe au prochain niveau
                        if (!collisionTresor(objScene3D.tabObjets3D[OBJ3D_TRESOR], intDirection, camera)) {
                            var binAucuneCollisionMur = true;
                            for (let i = 0; i < nbMur; i++) {
                                if (objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].binBriser) {
                                    binAucuneCollisionMur = true;
                                } else {
                                    binAucuneCollisionMur = !collisionRectangle(objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i], intDirection, camera);
                                }
                                // binAucuneCollisionMur = !collisionRectangle(objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i], intDirection, camera);
                                //si la caméra touche un mur, elle ne peut plus avancer dans cette direction
                                console.log(binAucuneCollisionMur);
                                if (binAucuneCollisionMur == false) {
                                    break;
                                }
                                //si la caméra touche le trésor il ne peut plus avancer dans cette direction et on passe au prochain niveau
                            }
                            if (!collisionTresor(objScene3D.tabObjets3D[OBJ3D_TRESOR], intDirection, camera) && binAucuneCollisionMur) {
                                setCibleCameraX(getCibleCameraX(camera) + fltXPrime, camera);
                                setCibleCameraZ(getCibleCameraZ(camera) + fltZPrime, camera);
                                setPositionCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                                setPositionCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
                            }
                        }
                        else { // Pour longer les murs s'il y a une collision
                            if (fltXCamera <= fltLimiteOuest || fltXCamera >= fltLimiteEst) {
                                // On longe le mur ouest ou est 
                                fltZPrime = 0.2 * ((fltZ < 0) ? -1 : 1); fltXPrime = 0.0;
                            }
                            else { // On longe le mur sud ou nord
                                fltXPrime = 0.2 * ((fltX < 0) ? -1 : 1); fltZPrime = 0.0;
                            }

                            // Nouvelles positions de la caméra
                            fltXCamera = getPositionX(camera) + fltXPrime;
                            fltZCamera = getPositionZ(camera) + fltZPrime;
                            binAucuneCollision = (fltXCamera > fltLimiteOuest) && (fltXCamera < fltLimiteEst) &&
                                (fltZCamera > fltLimiteNord) && (fltZCamera < fltLimiteSud);
                            // Longer le mur s'il ne rencontre pas un nouveau mur
                            if (binAucuneCollision) {
                                setCibleCameraX(getCibleCameraX(camera) + fltXPrime, camera);
                                setCibleCameraZ(getCibleCameraZ(camera) + fltZPrime, camera);
                                setPositionCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                                setPositionCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
                            }
                        }
                    }
                }
                else if (!isRestrictKeysActive && (event.keyCode == 32)) {//utilise ouvreur de murs
                    // 32 : espace
                    /* Trouve la direction dans laquelle le joueur regarde afin de briser le mur qui est toujours en face du joueur
                    Trouve la position du mur dans le tableau d'objet de murs et si c'est celui devant le joueur, on baisse le y de celui-ci */
                    intScore -= 50;
                    if (nbOuvreurs > 0) {
                        const directionRegard = determinerDirectionRegard(camera);
                        console.log('Direction de la caméra : ' + directionRegard);

                        let intXDevantCamera;
                        let intZDevantCamera;

                        if (directionRegard == 'nord') { // si regarde nord, x - 1
                            intXDevantCamera = Math.floor(getPositionCameraX(camera) - 1);
                            intZDevantCamera = Math.floor(getPositionCameraZ(camera));
                        } else if (directionRegard == 'sud') { // si regarde sud, x + 1
                            intXDevantCamera = Math.floor(getPositionCameraX(camera) + 1);
                            intZDevantCamera = Math.floor(getPositionCameraZ(camera));
                        } else if (directionRegard == 'est') { // si regarde est, z - 1
                            intXDevantCamera = Math.floor(getPositionCameraX(camera));
                            intZDevantCamera = Math.floor(getPositionCameraZ(camera) - 1);
                        } else if (directionRegard == 'ouest') { // si regarde ouest, z + 1
                            intXDevantCamera = Math.floor(getPositionCameraX(camera));
                            intZDevantCamera = Math.floor(getPositionCameraZ(camera) + 1);
                        }

                        let objMurABriser;

                        if (tabCarte[intXDevantCamera][intZDevantCamera] == 'd') {
                            for (let i = 0; i < nbMur; i++) {
                                let tabXYZ = getPositionsXYZ(objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i].transformations);
                                if (tabXYZ[0] == intXDevantCamera && tabXYZ[2] == intZDevantCamera) {
                                    objMurABriser = objScene3D.tabObjets3D[OBJ3D_MURSINTERIEUR + i];
                                    break;
                                }
                            }
                            tabMursOuverts.push(objMurABriser);
                            nbOuvreurs--;
                            ouvrirMur(objMurABriser);
                            console.log(getPositionX(objMurABriser.transformations), getPositionZ(objMurABriser.transformations));
                        }


                    }
                }

        }

        // cette fonction permet de déterminer dans quelle direction le joueur regarde
        // appelé lorsqu'on appuie sur espace
        function determinerDirectionRegard(camera) {
            const cibleCamera = {
                x: getCibleCameraX(camera),
                z: getCibleCameraZ(camera)
            };

            // Calcule l'angle entre la position de la caméra et la cible
            const angle = Math.atan2(cibleCamera.z, cibleCamera.x) * (180 / Math.PI);

            // Détermine la direction en fonction de l'angle
            let direction = '';
            if (angle >= -45 && angle < 45) {
                direction = 'sud';
            } else if (angle >= 45 && angle < 135) {
                direction = 'ouest';
            } else if (angle >= -135 && angle < -45) {
                direction = 'est';
            } else {
                direction = 'nord';
            }

            return direction;
        }

        function startTimer() {
            document.removeEventListener('keydown', startTimer);
            let camera = objScene3D.camera

            const timerInterval = setInterval(() => {
                seconds--;
                if (seconds < 0) {
                    seconds = 59;
                    minutes--;
                }
                //console.log(minutes, seconds)

                if (minutes < 0) {
                    clearInterval(timerInterval);
                    if (minutes < 0) {
                        intScore -= 200;
                        // Le joueur est retourné au milieu du dédale
                        setPositionsCameraXYZ([15, 0.5, 15], camera);
                        // La caméra regarde vers le sud
                        setCiblesCameraXYZ([-16, 0.5, 16], camera);
                        // Le mur de l'enclos est réouvert

                        //Les murs ouverts sont fermés
                        for (let i = 0; i < tabMursOuverts.length; i++) {
                            fermerMur(tabMursOuverts[i]);
                        }
                        //Le tableau de murs ouverts est vidé
                        tabMursOuverts.length = 0;
                        //Le nombre d'ouvreurs de murs est réinitialisé
                        nbOuvreurs = 4;

                        minutes = 1;
                        seconds = 0;
                        const formattedMinutes = minutes.toString().padStart(2, '0');
                        const formattedSeconds = seconds.toString().padStart(2, '0');
                        document.getElementById('lblTemps').textContent = `${formattedMinutes}:${formattedSeconds}`;

                        // Restaurer la position de la caméra
                        isRestrictKeysActive = false;
                        if (previousCameraPosition && previousCameraDirection) {
                            setPositionCameraX(previousCameraPosition.x, camera);
                            setPositionCameraY(previousCameraPosition.y, camera);
                            setPositionCameraZ(previousCameraPosition.z, camera);
                            setCibleCameraX(previousCameraDirection.x, camera);
                            setCibleCameraY(previousCameraDirection.y, camera);
                            setCibleCameraZ(previousCameraDirection.z, camera);
                            objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = true; //Afficher le ciel
                            for (let i = 0; i < nbFleches; i++) {
                                objScene3D.tabObjets3D[OBJ3D_FLECHE + i].binVisible = true;
                            }
                            objScene3D.tabObjets3D[OBJ3D_TRESOR].binVisible = true;
                        }

                        //attendre que le joueur appuie sur une touche pour recommencer
                        document.addEventListener('keydown', startTimer);
                    }
                } else {
                    const formattedMinutes = minutes.toString().padStart(2, '0');
                    const formattedSeconds = seconds.toString().padStart(2, '0');
                    document.getElementById('lblTemps').textContent = `${formattedMinutes}:${formattedSeconds}`;
                }
            }, 1000);

        }

        // startTimer();
    </script>
</head>

<body onload="demarrer()">
    <p class="titre"> Thesaurus Niveau: <span id="lblNiveau">1</span></p>
    <canvas id="monCanvas" width="640" height="640" tabIndex="1" onkeydown="deplacerCamera(); return false">
        Votre navigateur ne supporte pas la balise canvas
    </canvas>
    <p>
        <span class="padding">Score : <span id="lblScore">300</span></span>
        <span class="padding">Ouvreurs de murs : <span id="lblOuvreursMurs">4</span></span>
        <span class="padding">Temps : <span id="lblTemps">01:00</span></span>
    </p>

</body>

</html>