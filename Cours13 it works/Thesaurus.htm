<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Thesaurus Grégory Léa Marilyn Simon</title>
    <style>
        p {
            color: black;
            font-weight: bold;
            font-family: Georgia;
            font-size: 16pt;
            text-align: center;
            width: 640px;
        }

        .padding {
            padding: 10px 15px 10px 15px;
        }

        .titre {
            color: black;
            font-weight: bold;
            font-family: Georgia;
            font-size: 28pt;
            text-align: center;
            width: 640px;
        }
    </style>
    <script type="text/javascript" src="WebGl.js"></script>
    <script type="text/javascript" src="ShaderCouleursTextures.js"></script>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="Transformations.js"></script>
    <script type="text/javascript" src="Camera.js"></script>
    <script type="text/javascript" src="Sol.js"></script>
    <script type="text/javascript" src="Murs.js"></script>
    <script type="text/javascript" src="Creneaux.js"></script>
    <script type="text/javascript" src="Tunnels.js"></script>
    <script type="text/javascript" src="Ciel.js"></script>
    <script type="text/javascript" src="Textures.js"></script>
    <script type="text/javascript" src="Fleche.js"></script>
    <script type="text/javascript" src="Tresor.js"></script>
    <script type="text/javascript">

        let objgl = null;
        let objProgShaders = null;
        let objScene3D = null;
        let tabObjFleche = null;

        let isRestrictKeysActive = false;
        let previousCameraPosition = null;
        let previousCameraDirection = null;

        let tabElementsNiveau;
        const csvURL = 'niveau1.csv';

        /*Cette section est utilisé pour pouvoir itérer sur les objets 3D avec leur nom et, s'il y
        en a plusieurs, pouvoir utiliser une boucle avec le nombre connu d'objets 3D de ce type
        comme pour les flèches*/
        const OBJ3D_SOL = 0;
        const OBJ3D_MURS = 1;
        const OBJ3D_CIEL = 2;
        const OBJ3D_TRESOR = 3;
        const OBJ3D_FLECHE = 4;
        const OBJ3D_FLECHEJOUEUR = 5;

        const tabImages = ['Sol.jpg', 'Mur.jpg', 'Ciel.jpg', 'Fleche.jpg',
            'assets/TresorTextureGaucheDroite.jpg', 'assets/TresorTextureFace.jpg', 'assets/TresorTexturePanneauFaceHaut.jpg', 'assets/TresorTextureFaceArriereBas.jpg', 'assets/TresorTextureArriere.jpg', 'assets/TresorTextureDessus.jpg'];
        const TEX_SOL = 0;
        const TEX_MUR = 1;
        const TEX_CIEL = 2;
        const TEX_FLECHE = 3;
        const TEX_TRESORGAUCHEDROITE = 4;
        const TEX_TRESORFACE = 5;
        const TEX_TRESORFACEHAUT = 6
        const TEX_TRESORFACEARRIEREBAS = 7;
        const TEX_TRESORARRIERE = 8;
        const TEX_TRESORDESSUS = 9;

        //Longueur et largeur du niveau
        let longueurLargeurCarte = 31;

        // Le niveau actuel du jeu
        let intNiveau = 0;
        let intNbOuvreur = 4;

        // Le nombre de flèches : 18 - (intNiveau *2)
        let nbFleches = 1;

        function demarrer() {
            const objCanvas = document.getElementById('monCanvas');
            objgl = initWebGL(objCanvas);  // Initialise le contexte WebGL
            objProgShaders = initShaders(objgl);
            objSons = initSons();
            objScene3D = initScene3D(objgl); // Créer la scène

            effacerCanevas(objgl);
            dessiner(objgl, objProgShaders, objScene3D);
            animer();
        }

        // Un cycle d'animation	
        function animer() {
            // Requête pour le prochain cycle
            objCycleAnimation = requestAnimationFrame(animer);

            // Le cycle d'animation
            effacerCanevas(objgl);
            mettreAjourAnimation();
            dessiner(objgl, objProgShaders, objScene3D);
        }

        // Pour mettre à jour l'animation
        function mettreAjourAnimation() {
            document.getElementById('lblOuvreursMurs').innerHTML = intNbOuvreur;

            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + i];
                tournerFleche(i);
            }
        }

        function tournerFleche(intNoTornade) {
            const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + intNoTornade];
            let fltAngleY = getAngleY(obj3DFleche.transformations) + 0.5;
            if (fltAngleY > 360) fltAngleY -= 360;
            setAngleY(fltAngleY, obj3DFleche.transformations);
        }

        // function deplacerTornade(intNoTornade) {
        //     const obj3DTornade = objScene3D.tabObjets3D[OBJ3D_TORNADE + intNoTornade];
        //     if (obj3DTornade.binAutreDirection == null || obj3DTornade.binAutreDirection) {
        //         // Pour changer la direction de la tornade au hasard
        //         const intAngleHasard = Math.floor(Math.random() * 360);
        //         obj3DTornade.fltDeplacementX = Math.cos(intAngleHasard * Math.PI / 180) * 0.03;
        //         obj3DTornade.fltDeplacementZ = Math.sin(intAngleHasard * Math.PI / 180) * 0.03;
        //     }

        // La nouvelle position de la tornade
        //     const fltNouvellePositionX = getPositionX(obj3DTornade.transformations) + obj3DTornade.fltDeplacementX;
        //     const fltNouvellePositionZ = getPositionZ(obj3DTornade.transformations) + obj3DTornade.fltDeplacementZ;

        //     // S'assurer que la tornade ne dépasse pas les nurs
        //     const fltLimiteNord = -objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur / 2 + obj3DTornade.fltProfondeur;
        //     const fltLimiteSud = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur / 2 - obj3DTornade.fltProfondeur;
        //     const fltLimiteOuest = -objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur / 2 + obj3DTornade.fltLargeur;
        //     const fltLimiteEst = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur / 2 - obj3DTornade.fltLargeur;

        //     const binAucuneCollision = (fltNouvellePositionX > fltLimiteOuest) && (fltNouvellePositionX < fltLimiteEst) &&
        //         (fltNouvellePositionZ > fltLimiteNord) && (fltNouvellePositionZ < fltLimiteSud);

        //     if (binAucuneCollision) {
        //         // Déplacer dans la même direction
        //         setPositionX(fltNouvellePositionX, obj3DTornade.transformations);
        //         setPositionZ(fltNouvellePositionZ, obj3DTornade.transformations);
        //         // 1 chance sur 100 de changer de diection en cours de route
        //         obj3DTornade.binAutreDirection = Math.random() <= 0.01;
        //     }
        //     else { // Changement de direction à cause de la collision
        //         obj3DTornade.binAutreDirection = true;
        //     }

        //     // Vérification de la collision de la tornade avec la caméra
        //     const fltPositionXTornade = getPositionX(obj3DTornade.transformations);
        //     const fltPositionZTornade = getPositionZ(obj3DTornade.transformations);
        //     const fltPositionXCamera = getPositionCameraX(objScene3D.camera);
        //     const fltPositionZCamera = getPositionCameraZ(objScene3D.camera);

        //     obj3DTornade.binEnCollision = (fltPositionXCamera > fltPositionXTornade - obj3DTornade.fltLargeur) &&
        //         (fltPositionXCamera < fltPositionXTornade + obj3DTornade.fltLargeur) &&
        //         (fltPositionZCamera > fltPositionZTornade - obj3DTornade.fltProfondeur) &&
        //         (fltPositionZCamera < fltPositionZTornade + obj3DTornade.fltProfondeur);

        //     if (obj3DTornade.binEnCollision) {
        //         // Baisser le son du vent et
        //         // faire jouer le son de la tornade
        //         objSons.sonVent.volume = 0.50;
        //         objSons.sonTornade.play();

        //         obj3DTornade.intCompteur = 0;
        //         obj3DTornade.intAngleCameraPris = 0;
        //     }
        // }

        /*     function tournerCameraDansTornade(intNoTornade) {
                const obj3DTornade = objScene3D.tabObjets3D[OBJ3D_TORNADE + intNoTornade];
                const intNbCirconvolutions = obj3DTornade.intNbCirconvolutions;
                const fltDistRayon = 1 / (360 * intNbCirconvolutions);
                const intAngleCameraPris = obj3DTornade.intAngleCameraPris;
                const fltRayon = intAngleCameraPris * fltDistRayon;
                const fltLargeur = obj3DTornade.fltLargeur;
                const fltHauteur = obj3DTornade.fltHauteur;
                const fltProfondeur = obj3DTornade.fltProfondeur;
    
                setPositionsCameraXYZ([getPositionX(obj3DTornade.transformations) + Math.cos(intAngleCameraPris * Math.PI / 180) * fltRayon * fltLargeur,
                fltHauteur * fltRayon,
                getPositionZ(obj3DTornade.transformations) + Math.sin(intAngleCameraPris * Math.PI / 180) * fltRayon * fltProfondeur],
                    objScene3D.camera);
                setCiblesCameraXYZ([getPositionX(obj3DTornade.transformations), fltHauteur * fltRayon * 9 / 10, getPositionZ(obj3DTornade.transformations)],
                    objScene3D.camera);
                obj3DTornade.intAngleCameraPris += 17; obj3DTornade.intCompteur++;
    
                if (obj3DTornade.intCompteur >= 360 * intNbCirconvolutions / 17) {
                    // Arrêter le son du vent
                    objSons.sonVent.pause();
                    objSons.sonVent.currentTime = 0.0;
    
                    intNiveau = 0; // Le joueur doit recommencer
                    objScene3D = initScene3D(objgl);
                }
            } */

        function initScene3D(objgl) {
            document.getElementById('lblNiveau').innerHTML = intNiveau + 1

            const objScene3D = new Object();
            const tabObjets3D = new Array();

            // Mettre les textures dans la scène
            objScene3D.textures = creerTextures(objgl, tabImages);

            // Créer le sol
            const obj3DSol = creerObj3DSol(objgl, longueurLargeurCarte, TEX_SOL, intNiveau);
            tabObjets3D.push(obj3DSol);

            // Créer les murs
            const obj3DMurs = creerObj3DMurs(objgl, longueurLargeurCarte, TEX_MUR, intNiveau);
            tabObjets3D.push(obj3DMurs);

            // Créer le ciel
            const obj3DCiel = creerObj3DCiel(objgl, longueurLargeurCarte, TEX_CIEL);
            tabObjets3D.push(obj3DCiel);

            //Créer Trésor
            const obj3DTresor = creerObj3DTresor(objgl, [TEX_TRESORGAUCHEDROITE, TEX_TRESORFACE, TEX_TRESORFACEHAUT,
                TEX_TRESORFACEARRIEREBAS, TEX_TRESORARRIERE, TEX_TRESORDESSUS])
            tabObjets3D.push(obj3DTresor);

            //Créer Flèche
            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = creerObj3DFleche(objgl, TEX_FLECHE);
                tabObjets3D.push(obj3DFleche);
                setPositionFleche(1, 1, obj3DFleche);
            }

            // Créer le nextlevel
            // const obj3DNextLevel = creerObj3DNextLevel(objgl, obj3DTunnels, TEX_NEXTLEVEL);
            //tabObjets3D.push(obj3DNextLevel);

            // Créer les tornades
            //intNbTornades = Math.floor(intNiveau / 2) + 1;
            //for (let x = 0; x < intNbTornades; x++)
            //    tabObjets3D.push(creerObj3DTornade(objgl, obj3DMurs, obj3DCreneaux, TEX_TRANSPARENT, intNiveau));

            // Mettre les objets 3D sur la scène
            objScene3D.tabObjets3D = tabObjets3D;

            // La caméra
            const camera = creerCamera();
            setPositionsCameraXYZ([15.5, 0.5, 15.5], camera);
            setCiblesCameraXYZ([16.5, 0.5, 15.5], camera);
            setOrientationsXYZ([0, 1, 0], camera);
            objScene3D.camera = camera;

            //Oriente les flèches vers le trésor
            for (let i = 0; i < nbFleches; i++) {
                const obj3DFleche = objScene3D.tabObjets3D[OBJ3D_FLECHE + i];
                trouverCoffre(obj3DFleche, obj3DTresor);
            }

            /*  // Arrêter le son Next Level (si le son joue)
             if (!objSons.sonNextLevel.paused) {
                 objSons.sonNextLevel.pause();
                 objSons.sonNextLevel.currentTime = 0.0;
             }
 
             // Arrêter le son de la tornade (si le son joue)
             if (!objSons.sonTornade.paused) {
                 objSons.sonTornade.pause();
                 objSons.sonTornade.currentTime = 0.0;
             }
 
             // Faire jouer le son du vent au début du niveau
             objSons.sonVent.volume = 1.0;
             objSons.sonVent.play(); */

            return objScene3D;
        }

        function dessiner(objgl, objProgShaders, objScene3D) {
            // La vue
            objgl.viewport(0, 0, objgl.drawingBufferWidth, objgl.drawingBufferHeight);

            // Matrice de projection
            const matProjection = mat4.create();
            const fltRapportCanevas = objgl.drawingBufferWidth / objgl.drawingBufferHeight;
            mat4.perspective(55, fltRapportCanevas, 0.01, 100, matProjection);

            // Relier la matrice aux shaders
            objgl.uniformMatrix4fv(objProgShaders.matProjection, false, matProjection);

            for (let i = 0; i < objScene3D.tabObjets3D.length; i++) {
                const vertex = objScene3D.tabObjets3D[i].vertex;
                const couleurs = objScene3D.tabObjets3D[i].couleurs;
                const texels = objScene3D.tabObjets3D[i].texels;
                const maillage = objScene3D.tabObjets3D[i].maillage;
                const transformations = objScene3D.tabObjets3D[i].transformations;

                // Matrice du modèle            
                const matModeleVue = mat4.create();
                mat4.identity(matModeleVue);

                // Placer la caméra sur la scène
                mat4.lookAt(getPositionsCameraXYZ(objScene3D.camera),
                    getCiblesCameraXYZ(objScene3D.camera),
                    getOrientationsXYZ(objScene3D.camera),
                    matModeleVue);

                // Appliquer les transformations sur le modèle 
                mat4.translate(matModeleVue, getPositionsXYZ(transformations));
                mat4.scale(matModeleVue, getEchellesXYZ(transformations));
                mat4.rotateX(matModeleVue, getAngleX(transformations) * Math.PI / 180);
                mat4.rotateZ(matModeleVue, getAngleZ(transformations) * Math.PI / 180);
                //a été déplacé pour faire tourner les flèches sur eux mêmes
                mat4.rotateY(matModeleVue, getAngleY(transformations) * Math.PI / 180);

                // Relier la matrice aux shaders
                objgl.uniformMatrix4fv(objProgShaders.matModeleVue, false, matModeleVue);

                if (maillage == null)
                    // Dessiner les sous-objets
                    for (let j = 0; j < vertex.length; j++) {

                        // Relier les vertex aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex[j]);
                        objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);
                        const intNbVertex = (objgl.getBufferParameter(objgl.ARRAY_BUFFER, objgl.BUFFER_SIZE) / 4) / 3;

                        // Relier les couleurs aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs[j]);
                        objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0);

                        // Activer la texture
                        objgl.activeTexture(objgl.TEXTURE0 + texels[j].intNoTexture);
                        objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels[j].intNoTexture]);

                        // Relier les texels aux shaders
                        objgl.bindBuffer(objgl.ARRAY_BUFFER, texels[j]);
                        objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                        // Relier le no de texture et le taux de couleur aux shaders                 
                        objgl.uniform1i(objProgShaders.noTexture, texels[j].intNoTexture);
                        objgl.uniform1f(objProgShaders.pcCouleurTexel, texels[j].pcCouleurTexel);

                        // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                        if (i != OBJ3D_CIEL || objScene3D.tabObjets3D[i].binVisible == true) {
                            // Dessiner
                            objgl.drawArrays(vertex[j].typeDessin, 0, intNbVertex);
                        }
                    }
                else { // Dessiner le maillage

                    // Relier les vertex aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, vertex);
                    objgl.vertexAttribPointer(objProgShaders.posVertex, 3, objgl.FLOAT, false, 0, 0);

                    // Relier les couleurs aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, couleurs);
                    objgl.vertexAttribPointer(objProgShaders.couleurVertex, 4, objgl.FLOAT, false, 0, 0)

                    // Activer la texture
                    objgl.activeTexture(objgl.TEXTURE0 + texels.intNoTexture);
                    objgl.bindTexture(objgl.TEXTURE_2D, objScene3D.textures[texels.intNoTexture]);

                    // Relier les texels aux shaders
                    objgl.bindBuffer(objgl.ARRAY_BUFFER, texels);
                    objgl.vertexAttribPointer(objProgShaders.posTexel, 2, objgl.FLOAT, false, 0, 0);

                    // Relier le no de texture et le taux de couleur aux shaders                 
                    objgl.uniform1i(objProgShaders.noTexture, texels.intNoTexture);
                    objgl.uniform1f(objProgShaders.pcCouleurTexel, texels.pcCouleurTexel);

                    // Sélectionner le maillage qu'on va utiliser pour les triangles et les droites
                    objgl.bindBuffer(objgl.ELEMENT_ARRAY_BUFFER, maillage);

                    // Dessiner le ciel ou pas en se basant sur binVisible dans Ciel.js
                    if (i != OBJ3D_CIEL || objScene3D.tabObjets3D[i].binVisible == true) {
                        // Dessiner les triangles
                        objgl.drawElements(objgl.TRIANGLES, maillage.intNbTriangles * 3, objgl.UNSIGNED_SHORT, 0);
                        // Dessiner les droites à la suite des triangles
                        objgl.drawElements(objgl.LINES, maillage.intNbDroites * 2, objgl.UNSIGNED_SHORT, maillage.intNbTriangles * 2 * 3);
                    }
                }
            }
        }

        function effacerCanevas(objgl) {
            // Met la couleur d'effacement au noir et complétement opaque
            objgl.clearColor(0.0, 0.0, 0.0, 1.0);
            // Efface les couleurs et le buffer de profondeur.
            objgl.clear(objgl.COLOR_BUFFER_BIT | objgl.DEPTH_BUFFER_BIT);
        }

        function initSons() {
            const objSons = new Object();

            // Ce son joue tout au long du jeu
            let objSon = document.createElement('audio');
            objSon.setAttribute('src', 'SonVent.mp3');
            objSon.load();
            objSon.loop = true;
            objSons.sonVent = objSon;

            // Ce son joue lorsque le joueur passe au prochain niveau
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'SonNextLevel.mp3');
            objSon.load();
            objSon.loop = true;
            objSons.sonNextLevel = objSon;

            // Ce son joue lorsque le joueur est dans la tornade
            objSon = document.createElement('audio');
            objSon.setAttribute('src', 'SonTornade.mp3');
            objSon.load();
            objSon.loop = true;
            objSons.sonTornade = objSon;

            return objSons;
        }

        // Cette fonction sert à séparer le contenu en paramètre
        function separeFichier(csvContent) {
            const tabResultat = [];
            //On commence par séparer le document par lignes
            const tabLignes = csvContent.trim().split('\n'); // tabLignes est un tableau qui contient toute les lignes du document (1 élém du tab = 1 ligne)

            // Chaque ligne est split aux virgules et insérer dans tabColonnes, on insere ensuite le resultat dans tabResultat
            for (let i = 0; i < tabLignes.length; i++) {
                const tabColonnes = tabLignes[i].trim().split(','); // Trim to remove leading/trailing whitespace
                tabResultat.push(tabColonnes);
            }

            return tabResultat;
        }

        // Cette fonction sert à fetch le fichier et l'envoie à la fonction separeFichier pour séparer son contenu
        async function fetchCSV(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Failed to fetch CSV file');
                }
                const csvContent = await response.text();
                tabElementsNiveau = separeFichier(csvContent); //renvoie à la fonction separeFichier() et insère nos données dans la variable globale tabElementsNiveau
                return tabElementsNiveau;
            } catch (error) {
                throw new Error('Error fetching CSV file: ' + error.message);
            }
        }

        fetchCSV(csvURL).then(
            function (value) { console.log(tabElementsNiveau); /* code if successful */ },
            function (error) { console.error(error.message); /* code if some error */ }
        );

        /*fetchCSV(csvURL) // appel à la fonction fetchCSV(), c'est avec cet appel que la variable globale est remplie
            .catch(error => {
                console.error(error.message);
            });*/

        //NOTE: Si le joueur appui sur PageUp, puis PageDown, et ensuite bouge,
        //il se reteleportera à l'endroit sauver s'il rappui sur PageDown
        function restrictKeys(event) {
            // Key codes: CTRL = 17, SHIFT = 16, SPACE = 32
            var allowedKeys = [17, 16, 32];

            if (event.keyCode === 34) { // PageDown
                // Restaurer le contrôle des touches
                document.removeEventListener('keydown', restrictKeys);
                isRestrictKeysActive = false;
            }
        }

        function deplacerCamera() {
            const camera = objScene3D.camera;

            let fltX;
            let fltZ;
            let intDirection;
            let fltXPrime;
            let fltZPrime;
            let binAucuneCollision;
            let fltLimiteOuest2;
            let fltLimiteEst2;
            let fltLimiteNord2;
            let fltLimiteSud2;

            if (!isRestrictKeysActive && event.keyCode == 33) { // PageUp
                // Sauvegarder la position courante de la caméra
                previousCameraPosition = {
                    x: getPositionCameraX(camera),
                    y: getPositionCameraY(camera),
                    z: getPositionCameraZ(camera)
                };
                previousCameraDirection = {
                    x: getCibleCameraX(camera),
                    y: getCibleCameraY(camera),
                    z: getCibleCameraZ(camera)
                };

                // Bouger la caméra au millieu en haut
                setPositionCameraX(15.5, camera);
                setPositionCameraY(40, camera);
                setPositionCameraZ(15.1, camera);
                setCibleCameraX(15.5, camera);
                setCibleCameraY(0, camera); //La caméra regarde le bas
                setCibleCameraZ(15.5, camera);
                objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = false; //Cacher le ciel

                //Restreindre le mouvement
                document.addEventListener('keydown', restrictKeys);
                isRestrictKeysActive = true;
            } else if (isRestrictKeysActive && event.keyCode == 34) { // PageDown
                // Restaurer la position de la caméra
                if (previousCameraPosition && previousCameraDirection) {
                    setPositionCameraX(previousCameraPosition.x, camera);
                    setPositionCameraY(previousCameraPosition.y, camera);
                    setPositionCameraZ(previousCameraPosition.z, camera);
                    setCibleCameraX(previousCameraDirection.x, camera);
                    setCibleCameraY(previousCameraDirection.y, camera);
                    setCibleCameraZ(previousCameraDirection.z, camera);
                    objScene3D.tabObjets3D[OBJ3D_CIEL].binVisible = true; //Afficher le ciel
                }
            }

            if (!isRestrictKeysActive && (event.keyCode == 37 || event.keyCode == 39)) {
                // 37:  Flèche-à-gauche; 39:Flèche-à-droite
                fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                intDirection = (event.keyCode == 37) ? -1 : 1;
                const fltAngle = intDirection * Math.PI / 90; // Tourner 2 degrés
                fltXPrime = fltX * Math.cos(fltAngle) - fltZ * Math.sin(fltAngle);
                fltZPrime = fltX * Math.sin(fltAngle) + fltZ * Math.cos(fltAngle);
                setCibleCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                setCibleCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
            }
            else
                if (!isRestrictKeysActive && (event.keyCode == 38 || event.keyCode == 40)) {
                    // 38:  Flèche-en-haut; 40:Flèche-en-bas
                    fltX = getCibleCameraX(camera) - getPositionCameraX(camera);
                    fltZ = getCibleCameraZ(camera) - getPositionCameraZ(camera);
                    const fltRayon = Math.sqrt(fltX * fltX + fltZ * fltZ);
                    intDirection = (event.keyCode == 38) ? 1 : -1;

                    fltXPrime = intDirection * 0.2 * Math.cos(Math.acos(fltX / fltRayon));
                    fltZPrime = intDirection * 0.2 * Math.sin(Math.asin(fltZ / fltRayon));

                    // Positions de la caméra
                    let fltXCamera = getPositionX(camera) + fltXPrime;
                    let fltZCamera = getPositionZ(camera) + fltZPrime;

                    // Limites du mur
                    const fltLimiteOuest = 0.1;
                    const fltLimiteEst = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur - 0.1;
                    const fltLimiteNord = 0.1;
                    const fltLimiteSud = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur - 0.1;


                    binAucuneCollision = (fltXCamera > fltLimiteOuest) && (fltXCamera < fltLimiteEst) &&
                        (fltZCamera > fltLimiteNord) && (fltZCamera < fltLimiteSud);
                    let binFondTunnel = false;

                    /*if (!binAucuneCollision) {
                         Vérifier si le mur NORD est troué
                        if ((fltZCamera <= fltLimiteNord) && objScene3D.tabObjets3D[OBJ3D_MURS].tabAUntrou[NORD]) {
                            // Vérifier s'il est devant le trou du mur NORD
                            fltLimiteOuest2 = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur * (-1 / 2 + objScene3D.tabObjets3D[OBJ3D_MURS].tabDebutRelTrou[NORD]) + 0.1;
                            fltLimiteEst2 = fltLimiteOuest2 + objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeurTrou - 0.2;
                            binAucuneCollision = (fltXCamera > fltLimiteOuest2) && (fltXCamera < fltLimiteEst2);
                            // Vérifier s'il est au fond du tunnel
                            binFondTunnel = fltZCamera <= fltLimiteNord - objScene3D.tabObjets3D[OBJ3D_TUNNELS].fltProfondeur;
                        }
                        // Vérifier si le mur SUD est troué
                        else if ((fltZCamera >= fltLimiteSud) && objScene3D.tabObjets3D[OBJ3D_MURS].tabAUntrou[SUD]) {
                            // Vérifier s'il est devant le trou du mur SUD
                            fltLimiteEst2 = objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeur * (1 / 2 - objScene3D.tabObjets3D[OBJ3D_MURS].tabDebutRelTrou[SUD]) - 0.1;
                            fltLimiteOuest2 = fltLimiteEst2 - objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeurTrou + 0.2;
                            binAucuneCollision = (fltXCamera > fltLimiteOuest2) && (fltXCamera < fltLimiteEst2);
                            // Vérifier s'il est au fond du tunnel
                            binFondTunnel = fltZCamera >= fltLimiteSud + objScene3D.tabObjets3D[OBJ3D_TUNNELS].fltProfondeur;
                        }
                        // Vérifier si le mur EST est troué
                        else if ((fltXCamera >= fltLimiteEst) && objScene3D.tabObjets3D[OBJ3D_MURS].tabAUntrou[EST]) {
                            // Vérifier s'il est devant le trou du mur EST
                            fltLimiteNord2 = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur * (-1 / 2 + objScene3D.tabObjets3D[OBJ3D_MURS].tabDebutRelTrou[EST]) + 0.1;
                            fltLimiteSud2 = fltLimiteNord2 + objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeurTrou - 0.2;
                            binAucuneCollision = (fltZCamera > fltLimiteNord2) && (fltZCamera < fltLimiteSud2);
                            // Vérifier s'il est au fond du tunnel
                            binFondTunnel = fltXCamera >= fltLimiteEst + objScene3D.tabObjets3D[OBJ3D_TUNNELS].fltProfondeur;
                        }
                        // Vérifier si le mur OUEST est troué
                        else if ((fltXCamera <= fltLimiteOuest) && objScene3D.tabObjets3D[OBJ3D_MURS].tabAUntrou[OUEST]) {
                            // Vérifier s'il est devant le trou du mur OUEST
                            fltLimiteSud2 = objScene3D.tabObjets3D[OBJ3D_MURS].fltProfondeur * (1 / 2 - objScene3D.tabObjets3D[OBJ3D_MURS].tabDebutRelTrou[OUEST]) - 0.1;
                            fltLimiteNord2 = fltLimiteSud2 - objScene3D.tabObjets3D[OBJ3D_MURS].fltLargeurTrou + 0.2;
                            binAucuneCollision = (fltZCamera > fltLimiteNord2) && (fltZCamera < fltLimiteSud2);
                            // Vérifier s'il est au fond du tunnel
                            binFondTunnel = fltXCamera <= fltLimiteOuest - objScene3D.tabObjets3D[OBJ3D_TUNNELS].fltProfondeur;
                        }

                        // Il est dans un tunnel, baisser le volume
                        if (binAucuneCollision)
                            objSons.sonVent.volume = 0.25;
                    }
                    else // Il n'est pas dans un tunnel, monter le volume
                        objSons.sonVent.volume = 1.00;*/

                    if (collisionTresor(objScene3D.tabObjets3D[OBJ3D_TRESOR], intDirection, camera)) { // Passer à un autre niveau
                        // Arrêter le son du vent
                        // objSons.sonVent.pause();
                        // objSons.sonVent.currentTime = 0.0;

                        // Jouer le son du prochain niveau
                        // objSons.sonNextLevel.play();

                        intNiveau++;
                        objScene3D = initScene3D(objgl);
                    }
                    else if (binAucuneCollision) { // Déplacer la caméra
                        if (!collisionTresor(objScene3D.tabObjets3D[OBJ3D_TRESOR], intDirection, camera)) {
                            setCibleCameraX(getCibleCameraX(camera) + fltXPrime, camera);
                            setCibleCameraZ(getCibleCameraZ(camera) + fltZPrime, camera);
                            setPositionCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                            setPositionCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
                        }
                    }
                    else { // Pour longer les murs s'il y a une collision
                        if (fltXCamera <= fltLimiteOuest || fltXCamera >= fltLimiteEst) {
                            // On longe le mur ouest ou est 
                            fltZPrime = 0.2 * ((fltZ < 0) ? -1 : 1); fltXPrime = 0.0;
                        }
                        else { // On longe le mur sud ou nord
                            fltXPrime = 0.2 * ((fltX < 0) ? -1 : 1); fltZPrime = 0.0;
                        }

                        // Nouvelles positions de la caméra
                        fltXCamera = getPositionX(camera) + fltXPrime;
                        fltZCamera = getPositionZ(camera) + fltZPrime;
                        binAucuneCollision = (fltXCamera > fltLimiteOuest) && (fltXCamera < fltLimiteEst) &&
                            (fltZCamera > fltLimiteNord) && (fltZCamera < fltLimiteSud);
                        // Longer le mur s'il ne rencontre pas un nouveau mur
                        if (binAucuneCollision) {
                            setCibleCameraX(getCibleCameraX(camera) + fltXPrime, camera);
                            setCibleCameraZ(getCibleCameraZ(camera) + fltZPrime, camera);
                            setPositionCameraX(getPositionCameraX(camera) + fltXPrime, camera);
                            setPositionCameraZ(getPositionCameraZ(camera) + fltZPrime, camera);
                        }
                    }
                    console.log(getPositionCameraX(camera));
                    console.log(getPositionCameraY(camera));
                    console.log(getPositionCameraZ(camera));
                }
                else if (!isRestrictKeysActive && (event.keyCode == 32)) {
                    // 32 : espace
                    //prendre la position du joueur, prendre la position du mur devant lui / vérifier l'objet devant lui
                    //vérifier si ce mur est destructible, si oui on brise (enlève du tableau?) et on enlève un ouvreur de mur
                    //sinon on fait rien

                    //nord c'est x positif
                    //est c'est z positif

                    let fltXCibleCamera = getCibleCameraX(camera);
                    let fltZCibleCamera = getCibleCameraZ(camera);
                    let intXDevantCamera = Math.floor(fltXCibleCamera + 1);
                    let intZDevantCamera = Math.floor(fltZCibleCamera + 1);

                    console.log('X ' + fltXCibleCamera);
                    console.log('Z ' + fltZCibleCamera);

                    console.log('X math floor ' + intXDevantCamera);
                    console.log('Z math floor' + intZDevantCamera);

                    if (tabElementsNiveau[intXDevantCamera][intZDevantCamera] == 'd') {
                        //descend le Y pour enlever le mur
                        //setPositionY(-5, objScene3D.tabObjets3D[OBJ3D_MURS].transformations)
                        intNbOuvreur--;
                    }
                }
        }



    </script>
</head>

<body onload="demarrer()">
    <p class="titre"> Thesaurus Niveau: <span id="lblNiveau">1</span></p>
    <canvas id="monCanvas" width="640" height="640" tabIndex="1" onkeydown="deplacerCamera(); return false">
        Votre navigateur ne supporte pas la balise canvas
    </canvas>
    <p>
        <span class="padding">Score : <span id="lblScore">300</span></span>
        <span class="padding">Ouvreurs de murs : <span id="lblOuvreursMurs">4</span></span>
        <span class="padding">Temps : <span id="lblTemps">00:00</span></span>
    </p>
</body>

</html>